<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>周记1</title>
    <link href="/blog/20231122800059456/"/>
    <url>/blog/20231122800059456/</url>
    
    <content type="html"><![CDATA[<p>上个周末安排的很满，现在回想起来已经忘记当时做了什么了，但是应该都是大差不差的样子：取平台上买的菜、去菜市场买肉、洗衣服、打扫卫生、理发这些。<br>可能是周末没有休息好，周一上班非非非常累。在想着赶快过去吧。幸好周一不用加班。<br>周一晚上早早入睡，希望能够恢复以往的精力。</p><p>周二加班，晚上9点回来，只想看视频娱乐，完全提不起输入或输出的兴趣。晚11点半就洗漱休息了。</p><hr><p>这两天一直在看郑州的亮亮丽君夫妇的消息，得知他们被打后，决定离开郑州，也是，上有老，下有小，不为自己考虑，也要为家里人考虑。</p><hr><p>看到一篇公众号文章里提到</p><blockquote><p>《应得的权利》一书中说，情绪劳动是“女性为了密切关注生活中的小事所做的免费而无形的工作，这些工作加在一起就成为生活中的大事：情绪劳动是把家庭甚至社会凝聚在一起的黏合剂。情绪劳动包括很多——（出行前）密切关注各种信息、提前计划很多事情。这些工作经常都落在女性身上：知道什么东西在哪里、谁需要什么、杂货清单、家庭预算、家庭活动安排等——更不用说，还要收拾没完没了的包，小到尿布包，大到行李箱。”</p></blockquote><p>我一直有列事项清单的习惯，什么时候需要做什么事情，会设置提醒事项，生怕自己忘记。这个是读研的时候的习惯，因为当时一边上课，一边又要自学科研相关的。<br>现在工作了，自己在外独立生活，吃喝拉撒，什么事情都要操心。今天晚上回来就忘记去取快递了，很多这种明明记得要做，但是事情太多，就忘记了。<br>此外，做饭也需要消耗很多精力，准备食材，平台买菜，菜市场买肉。看b站的一个up，每天早上7点起来准备早饭和午饭，晚上也回家做饭。我是早饭看是否有时间做，有时间就做个手抓饼，没时间就吃个面包，或者到公司楼下买个包子，因为晚上休息的晚，早上7点30左右起。如果晚上要回来做饭，就要把肉先给放到冰箱保险中解冻，就这解冻的步骤，我忘记了好多次，晚上回来只能把肉拿出来当场滑动再切一下，一套晚饭操作下来，刷着视频流吃完饭基本上到了8点左右。</p><p>我还想自我提高一下，看下学习视频，或者写一些文字性技术性的输出，大多是流水账，或者是对于某件事的感触。</p><p>不是还有那句话吗，时间就像海绵里的水，只要愿意挤，总还是有的。</p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty-1</title>
    <link href="/blog/202304093691450081/"/>
    <url>/blog/202304093691450081/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><p>要见森林，不要局限于树木。</p><p>netty</p><p>把微服务中的服务的功能，使用中间件来解决。</p><p>将依赖代码注解变为 服务网格化编程，ServerMash。</p><p>把有侵入性的服务从代码中转嫁到中间件中。</p><p>netty 是解决通信问题的，效率要高。</p><p>还是要用 Spring Cloud 的，要用 RPC 的。</p><p>Dubbo RQ </p><h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><ul><li>Netty and 源码</li><li>RPC编程 grpc</li><li>Dubbo and 源码</li><li>MQ and rocketmq源码：(kafka rocketmq) 源码中rocketmq的使用</li><li>分布式算法：强一致性算法；对分布式领域的有更深入的理解；(CAP, 存储都是CP, AP)</li><li>SpringCloud and 源码</li></ul><blockquote><p>21min</p></blockquote><p>目的：认识到软件的思想，提高设计能力，了解目前系统架构的发展演变，与底层实现。</p><p>架构师和业务开发是两个工作。</p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Netty-是什么"><a href="#Netty-是什么" class="headerlink" title="Netty 是什么"></a>Netty 是什么</h2><p>Netty 是一个异步事件驱动的网络应用框架，解决的是服务器和客户端之间的通信问题。它是一个<strong>NIO客户服务器框架</strong>。<br>它是对Java中NIO的封装。</p><p>常用netty4版本。</p><h2 id="为什么需要-Netty-amp-amp-Netty能做什么"><a href="#为什么需要-Netty-amp-amp-Netty能做什么" class="headerlink" title="为什么需要 Netty &amp;&amp; Netty能做什么"></a>为什么需要 Netty &amp;&amp; Netty能做什么</h2><ul><li>它是行业内网络通信编程的标准，用于其他中间件的底层。</li><li>用于游戏行业；</li><li>框架的通信底层，解决进程间通信问题；</li><li>是分布式系统，通信的核心；</li></ul><h2 id="NIO是什么"><a href="#NIO是什么" class="headerlink" title="NIO是什么"></a>NIO是什么</h2><p>前面在Netty的介绍中提到，它是一个NIO客户服务器框架，那NIO是什么呢？</p><ul><li>NIO的全称是 None Blocking IO <strong>非阻塞IO</strong>，在JDK1.4中引入，用于解决阻塞的问题。</li><li>非阻塞的优点：能够在网络通信过程中，解决通信阻塞的问题，更加合理利用系统资源，提高系统并发效率。支持高并发的系统访问。</li></ul><h2 id="传统网络通信的开发方式（socket）和问题"><a href="#传统网络通信的开发方式（socket）和问题" class="headerlink" title="传统网络通信的开发方式（socket）和问题"></a>传统网络通信的开发方式（socket）和问题</h2><p>对于一个客户端的socket连接，会新创建一个线程。</p><h3 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h3><ol><li>线程创建资源开销大；</li><li>创建线程会占用内存，不能无限制创建；</li><li>CPU使用率高；</li></ol><h3 id="线程池的网络通信编程（池化）和问题"><a href="#线程池的网络通信编程（池化）和问题" class="headerlink" title="线程池的网络通信编程（池化）和问题"></a>线程池的网络通信编程（池化）和问题</h3><p>线程池的参数：</p><ol><li>core pool size：核心线程数，使用OS的cpu核数作为参数，但是JDK8以后的可以在虚拟机参数中指定核心线程数，因为Java应用往往跑在docker上，不知道机器的真实核数是多少了。</li><li>最大线程数量：</li></ol><p>优化方案：</p><ol><li>使用线程池预先定义好线程的数量，解决了线程不断创建的开销；</li><li></li></ol><h2 id="NIO如何解决阻塞问题-amp-amp-原理"><a href="#NIO如何解决阻塞问题-amp-amp-原理" class="headerlink" title="NIO如何解决阻塞问题 &amp;&amp; 原理"></a>NIO如何解决阻塞问题 &amp;&amp; 原理</h2><h2 id="Netty-的原理"><a href="#Netty-的原理" class="headerlink" title="Netty 的原理"></a>Netty 的原理</h2>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-31. 下一个排列</title>
    <link href="/blog/202208313370095749/"/>
    <url>/blog/202208313370095749/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode-31-下一个排列"><a href="#leetcode-31-下一个排列" class="headerlink" title="leetcode-31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">leetcode-31. 下一个排列</a></h2><ol><li>从后向前找，找非降序排列的第一个位置, nums[k-1] &lt; nums[k]</li><li>从后向前找，找</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[k<span class="hljs-number">-1</span>] &lt; nums[k]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> k--;<br>        &#125;<br>        <span class="hljs-comment">// 如果序列是 纯递减序列，就翻转一下</span><br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// nums[k-1] 和 k 是第一个 升序的，要在 k 后面找到比 nums[k-1] 大的最小的数</span><br>            <span class="hljs-type">int</span> t = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 从后向前找 t</span><br>            <span class="hljs-keyword">while</span> (t &gt; <span class="hljs-number">0</span> &amp;&amp; nums[t] &lt;= nums[k - <span class="hljs-number">1</span>]) t--;<br><br>            <span class="hljs-built_in">swap</span>(nums[k<span class="hljs-number">-1</span>], nums[t]); <span class="hljs-comment">// 把2个数交换</span><br>            <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转 nums[k] 后面的所有数，把降序变为升序</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-22. 括号生成</title>
    <link href="/blog/202208301142076060/"/>
    <url>/blog/202208301142076060/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode-22-括号生成"><a href="#leetcode-22-括号生成" class="headerlink" title="leetcode-22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">leetcode-22. 括号生成</a></h2><p>ACM模式</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">dfs:</span><br><span class="hljs-comment">一个合法的括号序列：</span><br><span class="hljs-comment">1、任意前缀中，左括号的数量 一定 &gt;= 右括号的数量</span><br><span class="hljs-comment">2、左右括号数量相等 n == n</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">_ _ _ _</span><br><span class="hljs-comment">什么情况下可以填左括号：lcnt &lt; n 就可以填</span><br><span class="hljs-comment">什么情况下可以填右括号：rcnt &lt; n &amp;&amp;  左括号数量严格大于右括号数量lcnt &gt; rcnt，</span><br><span class="hljs-comment">才能填</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> n;<br>vector&lt;string&gt; res;<br><br><span class="hljs-comment">// 括号的对数n，左括号个数lcnt，右括号个数rcnt，str括号序列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lcnt, <span class="hljs-type">int</span> rcnt, string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-comment">// if (u == 2*n)</span><br>    <span class="hljs-keyword">if</span> (lcnt == n &amp;&amp; rcnt == n)<br>        res.<span class="hljs-built_in">push_back</span>(str);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (lcnt &lt; n)<br>            <span class="hljs-built_in">dfs</span>(n, lcnt+<span class="hljs-number">1</span>, rcnt, str+<span class="hljs-string">&#x27;(&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (rcnt &lt; n &amp;&amp; lcnt &gt; rcnt)<br>            <span class="hljs-built_in">dfs</span>(n, lcnt, rcnt+<span class="hljs-number">1</span>, str+<span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : res) cout &lt;&lt; x &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心代码模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lcnt, <span class="hljs-type">int</span> rcnt, string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (lcnt == n &amp;&amp; rcnt == n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (lcnt &lt; n)<br>                <span class="hljs-built_in">dfs</span>(n, lcnt + <span class="hljs-number">1</span>, rcnt, str + <span class="hljs-string">&#x27;(&#x27;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (rcnt &lt; n &amp;&amp; lcnt &gt; rcnt)<br>                <span class="hljs-built_in">dfs</span>(n, lcnt, rcnt + <span class="hljs-number">1</span>, str + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团23秋招笔试后端</title>
    <link href="/blog/20220827589238093/"/>
    <url>/blog/20220827589238093/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022-08-27 美团笔试</p></blockquote><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>样例：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">input:</span><br><span class="hljs-number">7</span> <span class="hljs-number">3</span><br>abcaacc<br>a*c<br><br><span class="hljs-symbol">output:</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">// 美团0827第一题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">m 是短的那个子串的长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//bool check(string s1, string s2, int m)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="hljs-comment">//    for (int i = 0; i &lt; m; i++)</span><br><span class="hljs-comment">//    &#123;</span><br><span class="hljs-comment">//        if (s1[i] != &#x27;*&#x27; &amp;&amp; s1[i] != s2[i])</span><br><span class="hljs-comment">//            return false;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    return true;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    string s1, s2;<br><br>    cin &gt;&gt; s1 &gt;&gt; s2; <span class="hljs-comment">// s1 : abcaacc, s2: a*c</span><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">////////////////////////</span><br><span class="hljs-comment">//    for (int i = 0; i &lt;= n - m; i++)</span><br><span class="hljs-comment">//        // s1.substr(0, 3)左闭右开 -&gt; s1[0,2],</span><br><span class="hljs-comment">//        // 取s1的部分子串和 s2 进行比较，判断是否匹配，是返回1</span><br><span class="hljs-comment">//        res += check(s2, s1.substr(i, m), m) ? 1 : 0;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    cout &lt;&lt; res;</span><br><br>    <span class="hljs-comment">////////////////////////</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - m; i ++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 初始为true，如果s2和s1的子串tmp有不匹配的，就为false</span><br><br>        string tmp = s1.<span class="hljs-built_in">substr</span>(i, m); <span class="hljs-comment">// 子串的长度为 m</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s2[j] != <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; tmp[j] != s2[j])<br>                flag = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果满足m个字符都匹配，就把结果res ++;</span><br>        <span class="hljs-keyword">if</span> (flag) res ++;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><blockquote><p><a href="https://www.nowcoder.com/discuss/1030726?type=post&order=create&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=082010163EA881CF7BA3CDE559BD38F9-1661610238016">c++版本</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">input:</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">5 4 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">3 4 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">1 2 3 4 5</span><br><span class="hljs-comment">5 1 2 3 4</span><br><span class="hljs-comment">4 5 1 2 3</span><br><span class="hljs-comment">*3 4 5 1 2*</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-comment">// int a[N]; 使用vector而不是数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化vector</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        a[i - <span class="hljs-number">1</span>] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-comment">// 需要把x放到a数组的最左边，也就是先找到x并删除，再把x插入到a的首部</span><br>        a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), x));<br>        a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>(), x);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wangcfbj/article/details/70269995">c++与Java的容器对着</a></p><blockquote><p>Java版本</p></blockquote><p>其中 c++ 的 map 就是 Java 的 TreeMap, key-value映射，按照key有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt(), m = sc.nextInt();<br>        Map&lt;Integer, Integer&gt; k2v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 有序 map 的定义</span><br>        TreeMap&lt;Integer, Integer&gt; v2k = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((x, y) -&gt; y - x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            <span class="hljs-keyword">if</span> (k2v.containsKey(num)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> k2v.get(num);<br>                v2k.remove(v);<br>                k2v.put(num, i);<br>                v2k.put(i, num);<br>            &#125;<br>            k2v.put(num, i);<br>            v2k.put(i, num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : v2k.keySet()) System.out.print(v2k.get(v) + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!k2v.containsKey(i)) System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>第三题</p></li><li><p>第四题</p></li><li><p>第五题</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大疆测开笔试20220814</title>
    <link href="/blog/202208141197934275/"/>
    <url>/blog/202208141197934275/</url>
    
    <content type="html"><![CDATA[<p>1、<code>int * value [10][2]</code>, 32bit机器，问sizeof(*value)的大小?<br>个人感觉是4字节。32位机器；<br>如果是64位机器，int类型指针大小就是8字节的。</p><p>2、该正则表达式的匹配结果是？：<code>DJI\s(^Mavic|Mini)[0-3]?</code></p><p>3、 Linux系统中，进程的 VmHWM代表什么？<br>代表进程所占<strong>物理内存的峰值</strong>。</p><blockquote><p>cat &#x2F;proc&#x2F;pid&#x2F;status<br>VmPeak:     表示进程所占用最大虚拟内存大小<br>VmSize:      表示进程当前虚拟内存大小<br>VmLck:       表示被锁定的内存大小<br><strong>VmHWM:    表示进程所占用物理内存的峰值</strong><br>VmRSS:     表示进程当前占用物理内存的大小(与procrank中的RSS)<br>VmData:     表示进程数据段的大小<br>VmStk:       表示进程堆栈段的大小<br>VmExe:      表示进程代码的大小<br>VmLib:       表示进程所使用共享库的大小<br>VmPTE:      表示进程页表项的大小<br><a href="https://blog.csdn.net/weixin_38606457/article/details/125392137">查看某个进程占用空间大小 VmHWM VmRSS终极总结</a></p></blockquote><p>4、JVM的参数，<code>-Xmx10240m -Xms10240m -Xmn5120 -XX:SurvivorRatia=3</code>设置，问最小内存值 和 surviver区的总大小 分别是多少？</p><ul><li><strong>Xms</strong>: 指设定<strong>程序启动时占用的内存大小</strong>。</li><li><strong>Xmx</strong>：指设定程序运行期间<strong>最大可以占用的内存大小</strong>。如果程序运行时超出了这个设置值，就会报OutOfMemory异常。</li><li><strong>Xmn</strong>: 设置<strong>年轻代大小</strong>。<strong>整个堆大小&#x3D;年轻代大小+年老代大小+持久代大小。</strong></li><li>Xss:指设定的<strong>每个线程分配的堆栈内存大小</strong>。这个值根据程序，看一个线程大概需要多少内存，可能会有多少个线程同时运行来设置。</li><li><strong>XX:SurvivorRatia</strong>&#x3D;n, <strong>设置年轻代中 Eden区 与 2个Surviver区的大小比值</strong>。设置为3。注意 Survivor区 有2个。如n&#x3D;3，则表示Eden:Survivor&#x3D;3:2,一个Survivor区占年轻代的1&#x2F;5；如果设置为n&#x3D;4，则Eden:Sruvivor&#x3D;4:2, 一个Survivor区占年轻代的1&#x2F;6.</li></ul><p>结论：<br>所以最小内存值为 最初启动时的内存值，为Xms&#x3D;10240m,<br><code>-Xmn5120</code>说明年轻代大小是5120m，<code>-XX:SurvivorRatia=3</code>设置为3，说明Eden:Survivor&#x3D;3:2，一个Survivor区占年轻代的1&#x2F;5；所以一个Survivor区的大小为5120m*1&#x2F;5 &#x3D; 1024m, 但是年轻代中有2个Survivor区，所以 surviver区的总大小是 2048m.</p><p>5、Linux中，已有a.txt文件，哪个命令可以把该文件改名为txt.a ?<br>重定向机制， 使用<code>&gt;</code>表示输出到一个新文件中，使用<code>&gt;&gt;</code>表示输出到已有文件的末尾。如果文件已存在，直接操作文件，否者直接创建新文件。<br><a href="https://blog.csdn.net/Hongwei_1990/article/details/92382504">https://blog.csdn.net/Hongwei_1990/article/details/92382504</a><br><a href="https://www.51cto.com/article/207528.html">https://www.51cto.com/article/207528.html</a><br><a href="https://www.runoob.com/linux/linux-comm-cat.html">https://www.runoob.com/linux/linux-comm-cat.html</a></p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好未来笔试-Java-20220813</title>
    <link href="/blog/202208132751047154/"/>
    <url>/blog/202208132751047154/</url>
    
    <content type="html"><![CDATA[<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><p>1、异或运算<br>2、栈的先入后出性质<br>3、引用类型和值类型创建对象和调用函数时分别会创建几个t对象？</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>func(t);<br><br>函数定义如下：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(T t)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>4、throw和throws的区别</p><ol><li>throws 关键字用于声明异常，它的作用和try-catch类似；而throw 关键字用于显示地抛出异常</li><li>throws 关键字后面跟异常的名字；而 throw 关键字后面跟的是异常的对象</li><li>throws 关键字出现在方法签名上；而 throw 关键字出现在方法体内部；</li><li>throws 关键字在声明异常时可以跟多个异常，用逗号隔开；而 throw 关键字每次只能抛出一个异常；</li></ol><p>5、TCP套接字函数哪个函数会发生阻塞？哪个不会产生阻塞？<br>accept(), bind(), write(), read()</p><p>6、子类A，父类B，父子类中均有：构造函数、静态代码块、非静态代码块；问 new 一个子类对象，这6个部分的调用顺序是怎么样的？</p><p>7、</p><h1 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h1><p>计算机中你了解的端口号和对应的服务有哪些？</p><blockquote><p>昨天看图解TCP刚看了端口号相关的，结果就记住了22，80常用的，其他的都忘了。。</p></blockquote><p>知名端口号: 0-1023分配</p><p>动态分配端口号的取值范围：49152-65535之间。</p><p>TCP知名端口号：<br>端口号-服务<br><strong>21-FTP<br>22-SSH</strong><br>23-telnet<br>25-SMTP<br><strong>20-HTTP</strong><br><strong>443-HTTPS, http protocol over TLS&#x2F;SSL<br>53-DNS</strong></p><h1 id="编程1：leetcode208-实现Trie前缀树"><a href="#编程1：leetcode208-实现Trie前缀树" class="headerlink" title="编程1：leetcode208 实现Trie前缀树"></a>编程1：leetcode208 实现Trie前缀树</h1><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></p><blockquote><p>好家伙，我在c++编译器里一直报错，一看结果是没有切换成Java语言</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children; <span class="hljs-comment">// 当前节点有一个数组，存放子节点的值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isWord</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断到该节点的路径是否是一个完整的单词</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化前缀树对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isWord = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向前缀树中插入字符串 word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<span class="hljs-comment">// 当前this就是根节点</span><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>            <span class="hljs-comment">// 子节点为空，创建新的节点,移动到子节点</span><br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>                node = node.children[idx]; <span class="hljs-comment">// 移动到根节点的子节点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        node.isWord = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记字符串末尾</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断 word 是否是树中的完整字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-comment">// 数组索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>            <span class="hljs-comment">// 不存在，直接返回false</span><br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isWord;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断 树中是否有 word 出现，前缀也可以</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只要遍历完word了，就直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程2：leetcode-hard-25-K-个一组翻转链表"><a href="#编程2：leetcode-hard-25-K-个一组翻转链表" class="headerlink" title="编程2：leetcode hard 25. K 个一组翻转链表"></a>编程2：leetcode hard 25. K 个一组翻转链表</h1><p>高频题，刷的时候跳过了</p><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网常见问题记录</title>
    <link href="/blog/202208071957406245/"/>
    <url>/blog/202208071957406245/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更全、更深</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="一台服务器最大可以支撑多少条TCP连接？"><a href="#一台服务器最大可以支撑多少条TCP连接？" class="headerlink" title="一台服务器最大可以支撑多少条TCP连接？"></a>一台服务器最大可以支撑多少条TCP连接？</h2><p>理论上，一条TCP连接由一个四元组组成，分别是<strong>源IP地址，目的IP地址，源端口号，目的端口号</strong>。任意一个元素发生了改变，就代表的是一条完全不同的连接了。</p><p>对于服务端：<br>拿服务端的Nginx举例，服务端的IP地址是固定的，端口号是固定的80，只有源IP地址、源端口号是可变的。IPv4地址是32位，有$2^32$个IP数，端口号是16位，有$2^16&#x3D;65535$个port数。因此，理论上Nginx最多可以建立$2^32 * 2^16$个连接。</p><p>对于BS架构的浏览器端来说：<br>源IP地址和源端口号是不变的，目的端（服务器端）的端口号是80端口，是不变的，唯一可变的就是服务器端的IP地址是可变的。如果是IPv4网络下，IP地址是32位的，那么浏览器最多能够建立$2^32$个连接。</p><p>服务器能处理的并发数量和处理每个连接的数据处理工作量有关：<br>如果只建立连接不发送数据，不接收数据，服务器对cpu的需求就很少，只有处理连接握手的时候才需要一些资源。</p><p>但是，每维持一条TCP连接，就需要创建一个文件对象。（因为Linux是一切皆文件，socket也是文件）</p><h2 id="重发超时如何确定？"><a href="#重发超时如何确定？" class="headerlink" title="重发超时如何确定？"></a>重发超时如何确定？</h2><p>重发超时指的是 在重发数据之前，等待确认应答到来的那个特定时间间隔。<br>如果超过这个时间仍然没有收到确认应答，发送端就认为数据丢失，会重发数据。</p><p>TCP在发送数据包时会计算 往返时间（Round Trip Time, RTT，指报文段的往返时间）和偏差（往返时间波动的值、方差，有时也叫抖动）。</p><p><strong>重发超时的时间，是比 往返时间+偏差 稍大一点的值。</strong></p><ul><li>数据重发后，如果还是收不到确认应答，就再次发送数据。这时，重发时间会以2倍、4倍的指数函数变大。</li><li>数据不会被无线重发。达到一定重发次数后，还是收不到确认应答，就判断为网络或对方主机发生异常，强制关闭连接；并通知应用通信异常强行终止。</li></ul><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><p>TCP是面向连接的，面向连接是指在发生数据之前要先做好通信两端的准备工作，建立连接，然后再发送数据。<br>UDP是面向无连接的，不检查对端是否可以通信，直接将UDP包发送出去。</p><ul><li><p>TCP在数据通信前，通过TCP首部发送一个SYN包，请求建立连接，并等待对方的确认应答。如果对方发来确认应答ACK和SYN，则针对对方的SYN发送确认应答ACK，确认建立连接。</p></li><li><p>一个TCP连接的建立和断开，正常过程至少需要来回发送7个包才能完成：建立连接需要发送3个包，三次握手；断开连接4个包，4次挥手。</p></li></ul><h2 id="TCP以段位单位发送数据"><a href="#TCP以段位单位发送数据" class="headerlink" title="TCP以段位单位发送数据"></a>TCP以段位单位发送数据</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods</a></p></blockquote><h2 id="你知道哪些-HTTP-请求方法？"><a href="#你知道哪些-HTTP-请求方法？" class="headerlink" title="你知道哪些 HTTP 请求方法？"></a>你知道哪些 HTTP 请求方法？</h2><blockquote><p>HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。<br>其中 GET 和 POST 的区别是 …； 其中 OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法的作用是 …。</p></blockquote><h2 id="HTTP-1-0-和-HTTP-1-1-甚至和-HTTP-x2F-2-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-甚至和-HTTP-x2F-2-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 甚至和 HTTP&#x2F;2 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 甚至和 HTTP&#x2F;2 有什么区别？</h2><blockquote><p>HTTP 1.x ,HTTP&#x2F;2 的对比区别</p></blockquote><h5 id="ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？"><a href="#ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？" class="headerlink" title="ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？"></a>ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？</h5>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的值传递</title>
    <link href="/blog/202208063305694406/"/>
    <url>/blog/202208063305694406/</url>
    
    <content type="html"><![CDATA[<blockquote><p>尽量用自己的话说明白</p></blockquote><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><p>首先，Java中只有值传递。</p><ul><li>对于基本数据类型，传递的值的内容是 实参的值的拷贝；</li><li>对于对象，传递的值的内容是 实参的地址的拷贝；</li></ul><p>Java中调用函数时，传入的是实参，函数的定义中括号内的是形参。</p><h2 id="对于基本数据类型-int-double"><a href="#对于基本数据类型-int-double" class="headerlink" title="对于基本数据类型 int double"></a>对于基本数据类型 int double</h2><p>对于调用函数<code>func(int a)</code>，先将传入的实参复制一份，然后将该复制的值传递给形参。<br>形参得到的是一个值的复制，是局部的，对于这个局部值的改变不会影响实际参数的值。</p><h2 id="对于对象-Object"><a href="#对于对象-Object" class="headerlink" title="对于对象 Object"></a>对于对象 Object</h2><p>调用函数<code>func(Object obj)</code>，先将传入的实参的<strong>地址</strong>复制一份，然后将该地址的拷贝传递给被调函数的形参。<br>这样，现在就有2个地址的值，分别是原来的实参的地址和拷贝得到的地址，这两个地址指向堆中同一个对象。<br>此时，对于形参所指的对象进行变更，就会改变实际参数的值。</p><p>参考资料：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1659755520&amp;ver=3965&amp;signature=KUjgtEnSxCuO8nEbIM18w8Z8a4TEbXL0MdxMxSeNcDDnMcmk-oqgSsixtbFQQr7CDWCaYJX*nPD0xjb9pJTM-1F7fGH2qu7u5SN8QI3l7SrIM2vKHppWek8FQLQ2yggi&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1659755520&amp;ver=3965&amp;signature=KUjgtEnSxCuO8nEbIM18w8Z8a4TEbXL0MdxMxSeNcDDnMcmk-oqgSsixtbFQQr7CDWCaYJX*nPD0xjb9pJTM-1F7fGH2qu7u5SN8QI3l7SrIM2vKHppWek8FQLQ2yggi&amp;new=1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-200. 岛屿数量</title>
    <link href="/blog/202208021778491728/"/>
    <url>/blog/202208021778491728/</url>
    
    <content type="html"><![CDATA[<p>flood fill 算法</p><p>给定二位矩阵，搜索其中的1的连通块的数量</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul><li>岛屿问题：LC695&#x2F;LC827&#x2F;LC463&#x2F;LC200，+L1254+ LC994</li><li>被问到深度优先和广度优先的差别、计算时间空间复杂度</li><li>深度OR广度OR并查集都可</li><li>微软follow up题：827. 最大人工岛，MS follow up: 只允许一个水变成陆地，最大岛屿面积是多少？****<a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a>****</li><li><strong><strong><a href="https://www.cnblogs.com/lzw-lxy/p/16098424.html">leetcode 694 不同的岛屿数量</a></strong></strong></li><li>DFS+BFS+<strong>并查集</strong></li><li>网易互娱笔试</li><li>美团二面</li><li>火山一面</li><li>字节AI LAB一面</li><li>抖音后端二面</li><li>飞书2 15</li></ul><h1 id="方法1：DFS-找是1的陆地"><a href="#方法1：DFS-找是1的陆地" class="headerlink" title="方法1：DFS, 找是1的陆地"></a>方法1：DFS, 找是1的陆地</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j);<br>                    <span class="hljs-comment">// bfs(&#123;i, j&#125;);</span><br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-comment">// dfs代码</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 遍历过的位置，变为0, 防止重复遍历</span><br>        g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 向4个方向找1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-comment">// 计算 下一个位置的坐标(a,b)</span><br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-comment">// 下一个位置(a,b)上也是1，就继续dfs</span><br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; g[a][b] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-built_in">dfs</span>(a, b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法：DFS-，-避免0和2"><a href="#方法：DFS-，-避免0和2" class="headerlink" title="方法：DFS ， 避免0和2"></a>方法：DFS ， 避免0和2</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j);<br>                    <span class="hljs-comment">// bfs(&#123;i, j&#125;);</span><br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br><br>    <span class="hljs-comment">// dfs代码</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 遍历过的位置，标记为2, 防止重复遍历</span><br>        g[x][y] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <br>        <span class="hljs-comment">// 向4个方向找1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-comment">// 计算 下一个位置的坐标(a,b)</span><br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br><br>            <span class="hljs-comment">// 判断 base case</span><br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= g.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (g[a][b] == <span class="hljs-string">&#x27;2&#x27;</span> || g[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(a,b);<br><br>            <span class="hljs-comment">// 下一个位置(a,b)上也是1，就继续dfs</span><br>            <span class="hljs-comment">// if (a &gt;= 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; g[0].size() &amp;&amp; g[a][b] == &#x27;1&#x27;)</span><br>            <span class="hljs-comment">//     dfs(a, b);</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法2：BFS"><a href="#方法2：BFS" class="headerlink" title="方法2：BFS"></a>方法2：BFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// dfs(i,j);</span><br>                    <span class="hljs-built_in">bfs</span>(&#123;i, j&#125;);<br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(PII p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;PII&gt; q;<br>        q.<span class="hljs-built_in">push</span>(p);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            PII t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 拓展4个方向</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>            &#123;<br>                <span class="hljs-comment">// 下一个位置的坐标(a,b)</span><br>                <span class="hljs-type">int</span> a = t.first + dx[i], b = t.second + dy[i];<br>                <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= g.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || g[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                g[a][b] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                q.<span class="hljs-built_in">push</span>(&#123;a,b&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-20. 有效的括号</title>
    <link href="/blog/202208024026458204/"/>
    <url>/blog/202208024026458204/</url>
    
    <content type="html"><![CDATA[<h1 id="栈-map"><a href="#栈-map" class="headerlink" title="栈+map"></a>栈+map</h1><ul><li><p>最后判断栈是否为空，如果不为空说明有单独的左括号</p></li><li><p>这里最后一定要看看栈是不是空的！！！</p></li><li><p>阿里面试，问“左括号必须以正确的顺序闭合”，这个条件去掉如何实现？</p><p>  需要用三个遍历记录三种左括号的数量。然后遍历字符串，遍历过程中，遇到右括号就把对应的左括号的数量减去。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针？错！</span><br>        <span class="hljs-comment">// 栈 + map </span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; umap;<br><br>        umap[<span class="hljs-string">&#x27;[&#x27;</span>] = <span class="hljs-string">&#x27;]&#x27;</span>;<br>        umap[<span class="hljs-string">&#x27;(&#x27;</span>] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        umap[<span class="hljs-string">&#x27;&#123;&#x27;</span>] = <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)<br>        &#123;<br>            <span class="hljs-comment">// 如果是左括号，入栈</span><br>            <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(ch))<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 是右括号，</span><br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || umap[stk.<span class="hljs-built_in">top</span>()] != ch)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 如果所有括号都有效匹配，栈应为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-33. 搜索旋转排序数组</title>
    <link href="/blog/202208013616194023/"/>
    <url>/blog/202208013616194023/</url>
    
    <content type="html"><![CDATA[<p>二分：整数二分细节比较多，实数二分比较简单</p><p>二段性：找一个性质，第一段满足，第二段不满足，二分出边界点，边界点就是，满足性质的第一段的最后一个数。</p><p>两次2分，第一次二分出来数组中的断层的点，第二次在单调序列中二分找tar</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul><li>这道题要注意：如果面试官问你再旋转一次怎么做，做法还是一样的，无论旋转几次，最多只有2段递增序列</li><li>33的加强版是81题； 这两个题的基础是153和154题。</li><li>33-查找旋转数组不重复；81-查找旋转数组可重复复；153-旋转数组最小值不重复；154旋转数字最小值重复，这几个一起做做，二分的题目太难太细节，需要对比</li><li>二分。重点在于先判断哪半段是有序的，然后判断目标是否在有序的那半里面。</li><li>基础: 153.33. 进阶：154.81.</li></ul><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>两次二分，第一次二分找到左边区间的最大值；判断target在哪个区间，重新划分区间；第二次二分在新的区间中找target</p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc33-2022-08-02_101009.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 想法1：找到数组中下标i，满足nums[i] &gt; nums[i+1], 然后恢复数组为升序</span><br>        <span class="hljs-comment">// 接着使用二分，找tar</span><br>        <span class="hljs-comment">// y总思路：一般是有序，找一个二段性就可以二分，本题数组中间断开，所以先找断开的点在哪里</span><br>        <span class="hljs-comment">// 然后判断target是在断点的左边区间还是右边区间，再该区间中再次使用二分找到target</span><br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[<span class="hljs-number">0</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时 ，nums[r] 就是 前半部分的最大值</span><br><br>        <span class="hljs-comment">// 接着判断target在哪个部分</span><br>        <span class="hljs-keyword">if</span> (target &gt;= nums[<span class="hljs-number">0</span>]) l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> l = r + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 继续二分，在目标有序区间中找到target</span><br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时的l=r就是target的下标，如果没找到，就是-1</span><br>        <span class="hljs-keyword">if</span> (nums[r] == target) <span class="hljs-keyword">return</span> r;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-103. 二叉树的锯齿形层序遍历</title>
    <link href="/blog/202208012018291730/"/>
    <url>/blog/202208012018291730/</url>
    
    <content type="html"><![CDATA[<h1 id="实战案例："><a href="#实战案例：" class="headerlink" title="实战案例："></a>实战案例：</h1><ul><li>先是<strong>二叉树层序遍历</strong>，然后改成<strong>锯齿形遍历</strong>，除此之外，题目还要求符合一定的打印格式。一开始我是用的一个vector作为中间变量储存，然后面试官要求不用vector写一个优化的方法。然后我就考虑用<strong>双向队列</strong>。</li><li><strong>阿里变体，n叉树，3层为周期反转</strong></li><li>BFS加一个标记sign，sign为false表示从左到右，元素append到最后，true表示从右到左，元素append到最前面。每遍历一层转换下sign（sign &#x3D; !sign）</li><li>使用两个栈，利用栈的FILO特性实现反转</li><li>阿里面的时候考过这个题，我用了两个栈搞的哈哈哈，但是其实用个flag和一个count控制反转入栈的方向即可</li><li>双栈或者双端队列</li><li>微软算法题</li><li><strong>记得用dfs实现一遍</strong></li></ul><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>2点需要注意：</p><p>1、使用deque双端队列；</p><p>2、使用isLeft2Right来表示从左向右，还是从右向左，最后变更方向。</p><p>代码中注释为重要的，即为于常规的层序遍历不同的地方，因为本题每一层保存的数组顺序是不同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-comment">// 层序遍历的变体：使用双端队列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">bool</span> isLeft2Right = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重要：初始第0层根节点是 从左往右</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> qsize = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// vector&lt;int&gt; tmp; 把vec变为 deque 双向队列</span><br>            deque&lt;<span class="hljs-type">int</span>&gt; levelList; <span class="hljs-comment">// 重要：用 deque代替vector存数值</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; qsize; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-comment">// 重要：如果 isLeft2Right 为true，就把值放到 双端队列队尾，否则就放到队头</span><br>                <span class="hljs-keyword">if</span> (isLeft2Right) <br>                    levelList.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">else</span> <br>                    levelList.<span class="hljs-built_in">push_front</span>(node-&gt;val);<br>                <span class="hljs-comment">// tmp.push_back(node-&gt;val);</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-comment">// 重要：将deque队列保存到vector中，再放入res中</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(levelList.begin(), levelList.end())</span></span>;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-comment">// 重要：修改存储方向</span><br>            isLeft2Right = !isLeft2Right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>1、终止条件</p><p>2、层数level的判断条件</p><p>3、 如何保存val，根据level的奇偶判断</p><p>4、递归左右孩子节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 如果 level &gt;= res.size()说明下一层的集合还没创建，所以要先创建下一层的集合</span><br>        <span class="hljs-keyword">if</span> (level &gt;= res.<span class="hljs-built_in">size</span>()) <br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br>        <span class="hljs-comment">// 普通的保存val</span><br>        <span class="hljs-comment">// res[level].push_back(root-&gt;val);</span><br>        <br>        <span class="hljs-comment">// 根据level选择在vector的前面还是后面保存val，若 level为偶，则在 vector 的后面追加保存元素；</span><br>        <span class="hljs-comment">// 若为奇，则在vector的begin()开头插入值</span><br>        <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">else</span> res[level].<span class="hljs-built_in">insert</span>(res[level].<span class="hljs-built_in">begin</span>(), root-&gt;val);<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, level+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>); <span class="hljs-comment">// 根节点层的 层数 level = 0</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-142. 环形链表 II</title>
    <link href="/blog/202208013254481510/"/>
    <url>/blog/202208013254481510/</url>
    
    <content type="html"><![CDATA[<h2 id="环形链表三连问："><a href="#环形链表三连问：" class="headerlink" title="环形链表三连问："></a>环形链表三连问：</h2><ol><li><p>是否有环 141</p></li><li><p>找出环的入口 142</p></li><li><p>环中节点个数</p></li></ol><h2 id="如何计算环中节点个数"><a href="#如何计算环中节点个数" class="headerlink" title="如何计算环中节点个数?"></a>如何计算环中节点个数?</h2><p>idx1和idx2相遇在环的入口, 让idx2单独在环里再走一圈, 并进行计数, 当idx2→next &#x3D;&#x3D; idx1时, 返回count+1, 就是所谓的环中节点的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录环中节点个数, 最初节点个数为1</span><br><br>            <span class="hljs-keyword">if</span> (fast == slow)<br>            &#123;<br>                <span class="hljs-comment">// 找到相遇节点</span><br>                ListNode* idx1 = head;<br>                ListNode* idx2 = fast;<br>                <span class="hljs-keyword">while</span> (idx1 != idx2)<br>                &#123;<br>                    idx1 = idx1-&gt;next;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                <span class="hljs-comment">// 3 记录环中节点个数</span><br>                <span class="hljs-keyword">while</span> (idx2-&gt;next != idx1)<br>                &#123;<br>                    cnt++;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                cout &lt;&lt; cnt &lt;&lt; endl;<br>                <span class="hljs-comment">// 如果idx1=idx2，就是环的入口</span><br>                <span class="hljs-keyword">return</span> idx1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 链表无环返回NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>1 如何判断有环 2 环内相遇点 3 环的入口点</p><p>最重要的就是找到环的入口，</p><p>数学证明：</p><p>把环形链表分为三部分</p><ul><li>头节点—-》环的入口节点 的节点数是 x</li><li>环入口节点—》环内相遇节点 的节点数量是 y</li><li>相遇节点—》环入口节点 的节点数量是z</li></ul><p>快慢指针：</p><p>fast指针每次走2步，slow指针每次走1步</p><p>当fast和slow指针相遇的时候，因为slow指针走的慢，所以走了x+y个节点；</p><p>fast指针走的快，所以肯定会追上slow指针，所以一共走了 x+y + n(y+z)个节点；fast指针肯定要在环中多走几圈才能追上slow指针；</p><p>又因为fast指针走的步数是slow指针的2倍；</p><p>所以有 2*slow走的步数 &#x3D; fast走的步数，</p><p>即 2*(x+y) &#x3D;  x+y + n(y+z)，</p><p>化简得：</p><p>x+y &#x3D; n(y+z)，拆出来一个y+z，则有</p><p>x + y &#x3D; (n-1)*(y+z) + y + z</p><p>x &#x3D; (n-1)(y+z)  + z，其中n ≥ 1</p><p>当n&#x3D;1，时，有 x  &#x3D; z ;</p><p>即 下面2个节点数是相同的</p><ul><li>头节点—-》环的入口节点 的节点数是 x</li><li>相遇节点—》环入口节点 的节点数量是z</li></ul><p>因此，头节点位置是已知的，先找到快慢指针的相遇节点，</p><p>然后分别从头节点和相遇节点向下走1步，相遇的节点就是 环的入口节点。</p><p>先找到快慢指针相遇的节点，然后分别从头节点和相遇节点向前走，2指针相遇的地方，就是环的入口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 本题和 141 的区别，需要 返回链表开始入环的第一个节点</span><br><br>        <span class="hljs-comment">// 字节-判断是否有环，并打印首尾节点</span><br>        <span class="hljs-comment">// 写了个快慢指针，问能不能再优化</span><br>        <span class="hljs-comment">// x,y,z , 证明出 x = z就行 </span><br>        <span class="hljs-comment">// idx1从头节点出发，idx2从相遇节点出发，然后各自每次走1步，相遇的节点就是环的入口节点</span><br><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span> (fast == slow)<br>            &#123;<br>                <span class="hljs-comment">// 找到相遇节点</span><br>                ListNode* idx1 = head;<br>                ListNode* idx2 = fast;<br>                <span class="hljs-keyword">while</span> (idx1 != idx2)<br>                &#123;<br>                    idx1 = idx1-&gt;next;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果idx1=idx2，就是环的入口</span><br>                <span class="hljs-keyword">return</span> idx1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 链表无环返回NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-141. 环形链表</title>
    <link href="/blog/202208011400605890/"/>
    <url>/blog/202208011400605890/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针, 双指针</span><br>        <span class="hljs-comment">// fast 走2步，slow走1步，2指针相遇说明有环</span><br><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">// fast 走2步， slow 走1步</span><br>            fast = fast-&gt;next-&gt;next; <span class="hljs-comment">// 注意：fast-&gt;next 不能为 NULL, 否则会报空指针错误</span><br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-comment">// 直接比较 指针是否相等，不用比较 fast-&gt;val == slow-&gt;val了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-122. 买卖股票的最佳时机 II</title>
    <link href="/blog/202207313064434135/"/>
    <url>/blog/202207313064434135/</url>
    
    <content type="html"><![CDATA[<p><strong>本题可买—》卖多次</strong></p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc-122-2022-07-31_112441.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 可交易多次，即卖出状态可继续买入</span><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n ; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>-prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]), dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-121. 买卖股票的最佳时机</title>
    <link href="/blog/202207312393907320/"/>
    <url>/blog/202207312393907320/</url>
    
    <content type="html"><![CDATA[<p>前一天买入，未来一个不同的日子才能卖出</p><p><strong>不能多次交易，只能买—》卖一次</strong><br><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc121-2022-07-31_110458.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 买入股票，在后面卖出。可以买卖多次吗？应该是不可以</span><br>        <span class="hljs-comment">// dp[i][0]：持有股票的最大利润</span><br>        <span class="hljs-comment">// dp[i][1]：卖出股票的最大利润</span><br><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 二维数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>-prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-53. 最大子数组和</title>
    <link href="/blog/20220730390932531/"/>
    <url>/blog/20220730390932531/</url>
    
    <content type="html"><![CDATA[<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 子数组是连续的部分</span><br>        <span class="hljs-comment">// dp问题</span><br>        <span class="hljs-comment">// dp[i]:表示数组nums[0,i]的最大连续子数组的和为dp[i]</span><br>        <span class="hljs-comment">// dp[0] = nums[0]</span><br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; res) res = dp[i];<span class="hljs-comment">// 保存连续子数组最大和</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Untitled.png"></p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 贪心思路：遍历求和，如果和小于0，这和不要也罢，直接从下一个元素开始累加和</span><br><br>        <span class="hljs-type">int</span> res = INT32_MIN;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [-1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            sum += nums[i];<br>            <span class="hljs-comment">// 先使用sum更新res，否则先判断sum&lt;0的话会把sum的值变为0，就丢失了原来的值了。</span><br>            <span class="hljs-keyword">if</span> (sum &gt; res) res = sum;<span class="hljs-comment">// 先更新res</span><br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 再把小于0的sum变为0</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-21. 合并两个有序链表</title>
    <link href="/blog/20220730636993472/"/>
    <url>/blog/20220730636993472/</url>
    
    <content type="html"><![CDATA[<ul><li>迭代和递归写法</li><li>面试时会考虑去重，迭代去重在比较前判断pre和l1和l2的大小，决定是否要跳过该节点</li><li>变形：<strong>合并多个有序列表</strong>：<strong>合并多个有序链表的实现思路，分析时间复杂度和空间复杂度</strong>。方法：以合并两个链表的思路为基础，使用归并自底向上合并。还有小顶堆，也就是优先队列。</li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1000</span>); <span class="hljs-comment">// 虚拟节点，为了返回列表方便</span><br><br>        ListNode* pre = dummy; <span class="hljs-comment">// 操作指针</span><br><br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">NULL</span> &amp;&amp; list2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">// 如果需要去重的话，先比较pre-&gt;val 和 list1, list2的val</span><br>            <span class="hljs-comment">// if (pre-&gt;val == list1-&gt;val) list1 = list1-&gt;next;</span><br>            <span class="hljs-comment">// if (pre-&gt;val == list2-&gt;val) list2 = list2-&gt;next;</span><br><br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) <br>            &#123;<br>                pre-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>                pre = pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                pre-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>                pre = pre-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最终有一个链表没有遍历完，就接在pre的后面.</span><br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">NULL</span>) pre-&gt;next = list2;<br>        <span class="hljs-keyword">else</span> pre-&gt;next = list1;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l1;<br><br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) <br>        &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-83. 删除排序链表中的重复元素</title>
    <link href="/blog/20220730411341338/"/>
    <url>/blog/20220730411341338/</url>
    
    <content type="html"><![CDATA[<p>指定 cur 指针指向头部 head<br>当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了<br>当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果<br>如果不相等则 cur 移动到下一个位置继续循环<br>时间复杂度：O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        <br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) <br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-23. 合并K个升序链表</title>
    <link href="/blog/202207302660044243/"/>
    <url>/blog/202207302660044243/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// c++ 定义结构体，重载()，作为函数使用，使用优先队列实现小根堆</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode* a, ListNode* b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// 小根堆</span><br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;<br><br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">auto</span> tail = dummy;<br><br>        <span class="hljs-comment">// 把k个链表的头节点放入小根堆中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l : lists)<br>            <span class="hljs-keyword">if</span> (l) heap.<span class="hljs-built_in">push</span>(l);<br>        <br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-comment">// 取堆顶最小节点, 并弹出</span><br>            <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <br>            tail-&gt;next = t;<br>            tail = t;<br><br>            <span class="hljs-comment">// 堆插入代价是 O(logk)</span><br>            <span class="hljs-keyword">if</span> (t-&gt;next) heap.<span class="hljs-built_in">push</span>(t-&gt;next);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-102. 二叉树的层序遍历</title>
    <link href="/blog/202207303377955329/"/>
    <url>/blog/202207303377955329/</url>
    
    <content type="html"><![CDATA[<p>层序遍历都忘记了😂</p><p><strong>字节飞书：同时使用dfs和bfs来实现</strong></p><h2 id="BFS，层序遍历"><a href="#BFS，层序遍历" class="headerlink" title="BFS，层序遍历"></a>BFS，层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-comment">// 层序遍历使用 队列 </span><br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; res;<br>        <span class="hljs-comment">// 根节点不为空，入队</span><br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 获得队列大小，即当前层的节点个数</span><br>            <span class="hljs-type">int</span> qsize = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp; <span class="hljs-comment">// tmp 存储同层节点的值</span><br>            <br>            <span class="hljs-comment">// 一个for循环是一层的节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; qsize; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取队首元素</span><br>                q.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br><br>                <span class="hljs-comment">// 拓展队列</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-comment">// 保存一层的节点</span><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="DFS，迭代"><a href="#DFS，迭代" class="headerlink" title="DFS，迭代"></a>DFS，迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> deepth)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// cout &lt;&lt; deepth &lt;&lt; &quot;*&quot; &lt;&lt; res.size() &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (deepth &gt;= res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <br>        res[deepth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, deepth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, deepth+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-comment">// 递归</span><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-1. 两数之和</title>
    <link href="/blog/202207303502837159/"/>
    <url>/blog/202207303502837159/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// hashmap 存 &lt;int,int&gt; &lt;数字，下标&gt;</span><br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; umap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-comment">// 如果能够找到 target-nums[i]，说明 找到2个数和为target了，因为nums[i]已经在umap中了</span><br>            <span class="hljs-keyword">auto</span> iter = umap.<span class="hljs-built_in">find</span>(target-nums[i]);<br>            <span class="hljs-keyword">if</span> ( iter != umap.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp&#123;i, iter-&gt;second&#125;;<br>                <span class="hljs-keyword">return</span> tmp;<br>            &#125;<br><br>            <span class="hljs-comment">// 把nums[i]保存在umap中</span><br>            umap[nums[i]] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-2-数据类型与底层数据结构</title>
    <link href="/blog/202207291725346668/"/>
    <url>/blog/202207291725346668/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Redis中的字符串底层是简单动态字符串SDS。<br>比普通的字符串多了capacity和len存储容量信息和字符串已用大小信息。</p><h3 id="SDS结构体"><a href="#SDS结构体" class="headerlink" title="SDS结构体"></a>SDS结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SDS</span><br>&#123;<br>容量，字节数组的总容量<br>长度，字符串的长度<br>flag<br>byte[] content; 真正存放字符串的地方<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="embstr-和-raw的区别和内存分配"><a href="#embstr-和-raw的区别和内存分配" class="headerlink" title="embstr 和 raw的区别和内存分配"></a>embstr 和 raw的区别和内存分配</h3><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>长度小于1M时，加倍扩容；<br>长度大于1M，为了避免加倍扩容导致的空间浪费，每次扩容只会分配1M的冗余空间。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>什么场合下会用到字符串的append方法？</p><h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h2><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>比普通的数组多了4个字段，存储额外的信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-1-键值数据库的组成</title>
    <link href="/blog/20220729556998224/"/>
    <url>/blog/20220729556998224/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-8-事务隔离级别可重复读的原理</title>
    <link href="/blog/2022072724229572/"/>
    <url>/blog/2022072724229572/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-7-行锁</title>
    <link href="/blog/20220727124302134/"/>
    <url>/blog/20220727124302134/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-6-全局锁和表锁</title>
    <link href="/blog/202207263365794664/"/>
    <url>/blog/202207263365794664/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-5-索引2</title>
    <link href="/blog/202207261914332848/"/>
    <url>/blog/202207261914332848/</url>
    
    <content type="html"><![CDATA[<p>覆盖索引：一个索引覆盖了查询语句的查询需求，就称之为 覆盖索引。<br>优点：可以不回表，减少索引树的搜索次数，提升查询性能。</p><p>联合索引</p><p>最左前缀原则</p><p>索引下推优化：可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-92. 反转链表 II</title>
    <link href="/blog/202207242907969490/"/>
    <url>/blog/202207242907969490/</url>
    
    <content type="html"><![CDATA[<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>left和right只是第几个节点。</p><p>先找到left位置的节点的前一个节点，记为pre；这个pre的指向是永远不改变的。<br>然后left的位置的节点记为cur，下一个节点为next；<br>然后开始穿针引线;<br>把left后面的节点逐一地放到left前面，所以需要放right-left个节点;需要循环right-left次；</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 主要的循环体</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) <span class="hljs-comment">// [0, right-left-1] 共right-left次</span><br>&#123;<br>    next = cur-&gt;next;<br>    cur-&gt;next = next-&gt;next;<br>    next-&gt;next = pre-&gt;next;<br>    pre-&gt;next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/92.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode* pre = dummy;<br><br>        <span class="hljs-comment">// pre 走到 left的前一个位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br><br>        ListNode* cur = pre-&gt;next;<br>        ListNode* next;<br>        <span class="hljs-comment">// 0,1 ：循环改变的是left位置的节点的后面的节点，所以有 right-left个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right-left; i++)<br>        &#123;<br>            next = cur-&gt;next; <span class="hljs-comment">// 先 找到next</span><br>            cur-&gt;next = next-&gt;next; <span class="hljs-comment">// 1 变cur-&gt;next</span><br>            <span class="hljs-comment">//  2 变 next-&gt;next 用pre-&gt;next</span><br>            next-&gt;next = pre-&gt;next;<br>            pre-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-4-索引1</title>
    <link href="/blog/202207234234683209/"/>
    <url>/blog/202207234234683209/</url>
    
    <content type="html"><![CDATA[<p>哈希索引<br>优点：增加新的数据很快<br>缺点：因为链表不是有序的，所以哈希索引做区间查询的速度很慢<br>哈希表结构适合等值查询的场景。</p><p>有序数组对等值查询和范围查询场景中的效率都很高。<br>缺点：在更新数据的时候就比较难受了，效率很低<br>有序数组适合保存静态信息，用于静态存储引擎。</p><p>二叉搜索树–》平衡二叉树</p><p>为了让查询尽量地少读磁盘，所以要让树的高度尽量的低，所以有了N叉树</p><p>InnoDB的索引模型<br>在InnoDB中，表是根据主键顺序以索引的形式存放的。<br>每一个索引在InnoDB中对应一颗B+树。</p><p>根据B+树的叶子节点的不同：<br>索引类型可分为：主键索引和非主键索引<br>主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也叫聚簇索引。<br>非主键索引的叶子节点存的是主键的值。在InnoDB中，非主键索引也被称为二级索引。</p><p>基于非主键索引的查询需要多扫描一颗索引树。因此在应用中，应该尽量使用主键查询。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-206. 反转链表</title>
    <link href="/blog/202207222294061667/"/>
    <url>/blog/202207222294061667/</url>
    
    <content type="html"><![CDATA[<p>反转链表 经典题目 双指针</p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/20220722203704.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* cur = head; <span class="hljs-comment">// 快指针</span><br>        ListNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 慢指针</span><br>        ListNode* tmp; <span class="hljs-comment">// 临时指针，用于存储cur原先的下一个节点</span><br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            tmp = cur-&gt;next; <span class="hljs-comment">// 先保存cur-&gt;next节点</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 反转指针</span><br>            pre = cur; <span class="hljs-comment">// pre先后移</span><br>            cur = tmp; <span class="hljs-comment">// cur再后移</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-3-事务隔离级别的理解</title>
    <link href="/blog/202207223447866462/"/>
    <url>/blog/202207223447866462/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-2-SQL更新语句执行过程</title>
    <link href="/blog/202207214172393179/"/>
    <url>/blog/202207214172393179/</url>
    
    <content type="html"><![CDATA[<p>首先，我们创建表T:<br>有主键ID和列c<br><code>create table T(ID int primary key, c int);</code></p><p>然后使用更新语句去更新ID&#x3D;2的c的值：<br><code>update T set c=c+1 where ID=2;</code></p><p>更新语句流程：<br>更新语句的执行流程，也像查询语句一样，<br>连接器连接数据库–》分析器进行词法语法分析知道这是更新语句–》优化器决定使用ID索引–》执行器找到ID&#x3D;2的这一行，进行更新</p><p>但是更新语句设计到两个日志模块：（设计思路可借鉴）</p><ol><li>redo log 重做日志</li><li>binlog 归档日志</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-1-SQL查询语句执行过程</title>
    <link href="/blog/202207211434806580/"/>
    <url>/blog/202207211434806580/</url>
    
    <content type="html"><![CDATA[<p>MySQL可以分为客户端和服务器端。<br>服务器端中，可分为Server层和存储引擎层。</p><p>Server层中包括：</p><ul><li>连接器：管理连接，进行权限验证</li><li>查询缓存：如果查询结果已在缓存中，直接返回</li><li>分析器：进行词法分析、语法分析</li><li>优化器：进行语句优化、索引选择</li><li>执行器：操作引擎，返回结果</li></ul><p>存储引擎层负责数据的存储和提取，是插件式的，可以选择各个存储引擎。</p><p>一条查询语句的执行过程：</p><p>客户端连接服务端：连接器—》分析器—》优化器—》执行器—》存储引擎</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>acwing-785. 快速排序</title>
    <link href="/blog/20220721820422519/"/>
    <url>/blog/20220721820422519/</url>
    
    <content type="html"><![CDATA[<p>给定你一个长度为 n 的整数数列。</p><p>请你使用快速排序对这个数列按照<strong>从小到大进行排序</strong>。</p><p>并将排好序的数列按顺序输出。</p><p>输入格式<br>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 $1∼10^9$ 范围内），表示整个数列。</p><p>输出格式<br>输出共一行，包含 n 个整数，表示排好序的数列。</p><p>数据范围<br>1≤n≤100000</p><p>输入样例：<br>5<br>3 1 2 4 5<br>输出样例：<br>1 2 3 4 5</p><h2 id="2022-7-25二刷"><a href="#2022-7-25二刷" class="headerlink" title="2022 7 25二刷"></a>2022 7 25二刷</h2><p><strong>需要注意的：<br>1、递归返回条件；<br>2、do while 的条件；<br>3、if的条件；<br>4、递归的参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 递归返回条件，只剩一个元素就有序了，直接返回</span><br><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l+r&gt;&gt;<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br><br>        <span class="hljs-built_in">quick_sort</span>(nums, l, j);<br>        <span class="hljs-built_in">quick_sort</span>(nums, j+<span class="hljs-number">1</span>, r);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 快速排序</span><br>        <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="快排模板quick-sort，熟记"><a href="#快排模板quick-sort，熟记" class="headerlink" title="快排模板quick_sort，熟记"></a>快排模板<code>quick_sort</code>，熟记</h2><p><strong>注意：</strong><br><code>do i++; while(q[i] &lt; x);</code> &#x2F;&#x2F; **从小到大排序，左边都是 &lt;&#x3D; x的**<br><code>do j--; while(q[j] &gt; x);</code> &#x2F;&#x2F; <strong>从小到大排序，右边都是 &gt;&#x3D; x的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//递归的终止情况</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//第一步：分成子问题</span><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x); <span class="hljs-comment">// 从小到大排序，左边都是 &lt;= x的</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x); <span class="hljs-comment">// 从小到大排序，右边都是 &gt;= x的</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">//第二步：递归处理子问题</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br>    <br>    <span class="hljs-built_in">quick_sort</span>(q, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-215. 数组中的第K个最大元素</title>
    <link href="/blog/202207212586962165/"/>
    <url>/blog/202207212586962165/</url>
    
    <content type="html"><![CDATA[<p>求第k个最大的元素，<br>从大到小排序，取第k个数，即为第k个最大的元素。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>先按从大到小排序，时间复杂度<code>O(nlogn)</code>, 返回 <code>nums[k-1]</code>。</p><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><h3 id="快速选择算法，递归"><a href="#快速选择算法，递归" class="headerlink" title="快速选择算法，递归"></a>快速选择算法，递归</h3><p>时间<code>O(n)</code>, 空间<code>O(logn)</code>：因为有递归栈空间<code>O(logn)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[l];<br><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// x 建议选 nums[l + r &gt;&gt; 1]</span><br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &gt; x); <span class="hljs-comment">// 左边均是 &gt;= x的，从大到小排序</span><br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &lt; x); <span class="hljs-comment">// 右边均是 &lt;= x的，但是代码里要写成 &lt; x;</span><br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 递归一侧</span><br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, j + <span class="hljs-number">1</span>, r, k - sl);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="快速选择算法，非递归（优化空间）"><a href="#快速选择算法，非递归（优化空间）" class="headerlink" title="快速选择算法，非递归（优化空间）"></a>快速选择算法，非递归（优化空间）</h3><p>去掉递归栈空间，用while循环<br>时间<code>O(n)</code>, 空间<code>O(1)</code>, 空间复杂度最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 用while循环</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[l];<br><br>            <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// x 建议选 nums[l + r &gt;&gt; 1]</span><br>            <span class="hljs-keyword">while</span> (i &lt; j)<br>            &#123;<br>                <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &gt; x); <span class="hljs-comment">// 左边均是 &gt;= x的，从大到小排序</span><br>                <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &lt; x); <span class="hljs-comment">// 右边均是 &lt;= x的，但是代码里要写成 &lt; x;</span><br>                <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>            &#125;<br><br>            <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (k &lt;= sl) <br>                r = j; <span class="hljs-comment">// 更新参数r</span><br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-comment">// 实测，先更新k要快些</span><br>                k = k - sl, l = j + <span class="hljs-number">1</span>; <span class="hljs-comment">// 先更新k再更新l，因为k用到了原来的l，不过我这里用sl保存了，按理说先更新l也可以</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>最小堆：时间<code>O(nlogk)</code>, 空间<code>O(k)</code></p><p>使用STL建立小根堆：<br><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q;</code></p><p>建立大根堆：<br><code>priority_queue&lt;int&gt; Qmin;</code></p><p>堆使用于什么题目和情况下呢？<br>关键字：第k个。和第k个相关，就可以尝试用堆。<br>维护动态数据的最大和最小值，可以考虑堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 小根堆，顶部元素是最小值，保持堆内只有k个元素，这样堆顶元素就是第k个最大的元素</span><br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; Q;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">// 如果堆中元素数量 Q.size() &lt; k个，就把当前的元素加入堆中</span><br>            <span class="hljs-keyword">if</span> (Q.<span class="hljs-built_in">size</span>() &lt; k) <br>                Q.<span class="hljs-built_in">push</span>(nums[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Q.<span class="hljs-built_in">top</span>() &lt; nums[i])<span class="hljs-comment">// 如果堆顶元素 &lt; 当前元素nums[i]，就更新堆顶</span><br>            &#123;<br>                Q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出堆顶元素</span><br>                Q.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 新元素入堆，替换堆顶</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回堆顶元素，即为第k个最大的元素</span><br>        <span class="hljs-keyword">return</span> Q.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速选择和堆算法的适用场景</p><ul><li><code>快速选择</code>只适用于 确定数量的情况下，即<code>数组的数量是固定的，静态不变的</code>。</li><li>如果是<code>动态情况，数组数量不是确定的</code>，就<code>只能用堆的方法</code>。堆的方法也有小根堆和大根堆可以选择，小根堆的时间复杂度较优，</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing-786. 第k个数</title>
    <link href="/blog/202207212484269659/"/>
    <url>/blog/202207212484269659/</url>
    
    <content type="html"><![CDATA[<p>从小到大排序，取第k个数。</p><h3 id="快速选择算法，非递归"><a href="#快速选择算法，非递归" class="headerlink" title="快速选择算法，非递归"></a>快速选择算法，非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-comment">// 快速选择算法，非递归</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l]; <span class="hljs-comment">// 当[l,r]之间只剩一个元素，就是答案</span><br>    <br>    <span class="hljs-type">int</span>  i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x); <span class="hljs-comment">// 左边left 均 &lt;= x</span><br>        <span class="hljs-keyword">do</span> j-- ; <span class="hljs-keyword">while</span> (q[j] &gt; x); <span class="hljs-comment">// 右边right 均 &gt;= x</span><br>        <br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, l, j, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r, k-sl);<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">quick_sort</span>(q, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, k) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速选择算法，递归"><a href="#快速选择算法，递归" class="headerlink" title="快速选择算法，递归"></a>快速选择算法，递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-comment">// 快速选择算法，递归</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l]; <span class="hljs-comment">// 当[l,r]之间只剩一个元素，就是答案</span><br>        <br>        <span class="hljs-type">int</span>  i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x); <span class="hljs-comment">// 左边left 均 &lt;= x ， 从小到大排序</span><br>            <span class="hljs-keyword">do</span> j-- ; <span class="hljs-keyword">while</span> (q[j] &gt; x); <span class="hljs-comment">// 右边right 均 &gt;= x</span><br>            <br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <br>            <span class="hljs-comment">// return quick_sort(q, l, j, k);</span><br>            r = j;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-comment">// return quick_sort(q, j + 1, r, k-sl);  </span><br>            k = k - sl,l = j + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">quick_sort</span>(q, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, k) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-146.LRU缓存</title>
    <link href="/blog/20220720324114325/"/>
    <url>/blog/20220720324114325/</url>
    
    <content type="html"><![CDATA[<h3 id="java写法，c-的代码一直调不对，不知道怎么了。思路就是自定义一个双向链表的类DLinkedNode，然后一个map-lt-int-DLinkedNode-gt-存key所对应的链表节点。"><a href="#java写法，c-的代码一直调不对，不知道怎么了。思路就是自定义一个双向链表的类DLinkedNode，然后一个map-lt-int-DLinkedNode-gt-存key所对应的链表节点。" class="headerlink" title="java写法，c++的代码一直调不对，不知道怎么了。思路就是自定义一个双向链表的类DLinkedNode，然后一个map&lt;int,DLinkedNode&gt;存key所对应的链表节点。"></a>java写法，c++的代码一直调不对，不知道怎么了。思路就是自定义一个双向链表的类DLinkedNode，然后一个map&lt;int,DLinkedNode&gt;存key所对应的链表节点。</h3><p>tips:</p><p>使用 2个虚拟头节点和虚拟尾节点会更加方便处理链表节点的删除和插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">// 定义双向链表的类：值，前后指针，无参构造器和有参构造器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v)</span> &#123;key = k; value = v;&#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义map、大小、容量、和虚拟头尾节点</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode head, tail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>; <span class="hljs-comment">// size记录 放到map和链表中的节点的个数，不能超过capacity</span><br>        <span class="hljs-built_in">this</span>.capacity = capacity; <span class="hljs-comment">// 是LRU的容量</span><br>        <span class="hljs-comment">// 虚拟头节点和尾节点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        <span class="hljs-comment">// 初始化双向链表</span><br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">// 1 删除 节点</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(DLinkedNode node)</span><br>    &#123;<br>        node.next.prev = node.prev;<br>        node.prev.next = node.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 2 添加节点到链表首部 </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(DLinkedNode node)</span><br>    &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 节点 移动到链表首部</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span><br>    &#123;<br>        <span class="hljs-comment">// 1 删除 节点</span><br>        removeNode(node);<br>        <span class="hljs-comment">// 2 添加节点到链表首部 </span><br>        addToHead(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-comment">// 从map中尝试获取 key 所对应的node，如果node不存在，则返回-1</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果key存在，将node移动到链表首部, 最后返回key对应的node的值</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除尾节点，并返回</span><br>    DLinkedNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 1 得到尾节点</span><br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> tail.prev;<br>        <span class="hljs-comment">// 2 删除节点</span><br>        removeNode(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-comment">// 如果 key 不存在</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">// 那就新建 node ，并加入 map 和 链表首部</span><br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key, value);<br>            cache.put(key, newNode); <span class="hljs-comment">// 存到cache map中</span><br>            addToHead(newNode);<span class="hljs-comment">// 加入到链表首部</span><br>            ++size;<span class="hljs-comment">// 节点数量+1</span><br>            <span class="hljs-comment">// 如果 链表中的数量 大于 capacity，就要删除链表尾节点</span><br>            <span class="hljs-keyword">if</span> (size &gt; capacity)<br>            &#123;<br>                <span class="hljs-comment">// 删除尾节点，尾节点就是最近最少使用的节点，删除后并返回该节点，因为在map中也要删除对应的k-v项</span><br>                <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> removeTail();<br>                cache.remove(removed.key); <span class="hljs-comment">//在map中删除对应的key</span><br>                --size; <span class="hljs-comment">// 节点数量 - 1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果key存在，更新value, 并把节点移动到链表首部</span><br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="c-写法"><a href="#c-写法" class="headerlink" title="c++写法"></a>c++写法</h3><p>？ size前有int 输出结果就和预期的不一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    <span class="hljs-built_in">DLinkedNode</span>() : <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;; <span class="hljs-comment">// 定义双向链表结构体</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 定义哈希表</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, DLinkedNode*&gt; cacheLinked;<br>    <span class="hljs-comment">// 定义虚拟头节点和尾节点</span><br>    DLinkedNode* dummy_head;<br>    DLinkedNode* dummy_tail;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity) &#123;<br>        size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ？ size前有int 输出结果就和预期的不一致</span><br>        capacity = _capacity;<br>        dummy_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        dummy_tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        dummy_head-&gt;next = dummy_tail;<br>        <span class="hljs-comment">// dummy_tail-&gt;next 错了，应该是dummy_tail-&gt;prev</span><br>        dummy_tail-&gt;prev = dummy_head;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 删除</span><br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        node-&gt;prev = dummy_head;<br>        node-&gt;next = dummy_head-&gt;next;<br>        dummy_head-&gt;next-&gt;prev = node;<br>        dummy_head-&gt;next = node;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 删除</span><br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-comment">// 移动到首部</span><br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cacheLinked.<span class="hljs-built_in">count</span>(key)) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// key 存在, 得到node, 并把node移动到链表首部</span><br>        DLinkedNode* node = cacheLinked[key];<br>        <span class="hljs-built_in">moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node-&gt;value;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除尾部节点</span><br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 获得尾部节点</span><br>        DLinkedNode* node = dummy_tail-&gt;prev;<br>        <span class="hljs-comment">// 删除</span><br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 判断key是否存在, 如果存在, 就把对应节点更新value，并移动到链表首部</span><br>        <br>        <span class="hljs-keyword">if</span> (!cacheLinked.<span class="hljs-built_in">count</span>(key))<br>        &#123;<br>            <span class="hljs-comment">// 如果key不存在，则创建新的节点，插入到链表首部，再添加到map中</span><br>            DLinkedNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>            <br>            cacheLinked[key] = node;<br>            <span class="hljs-built_in">addToHead</span>(node);<br>            ++size; <span class="hljs-comment">// 双向链表长度+1</span><br><br>            <span class="hljs-comment">// 如果超出容量，就删除双向链表的尾部节点, 再删除map中的项</span><br>            <span class="hljs-keyword">if</span> (size &gt; capacity)<br>            &#123;<br>                DLinkedNode* removed = <span class="hljs-built_in">removeTail</span>();<br>                cacheLinked.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br><br>                <span class="hljs-keyword">delete</span> removed; <span class="hljs-comment">// 防止内存泄漏</span><br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            DLinkedNode* node = cacheLinked[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>双向链表</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word2019 没有mathtype6.9a 选项卡</title>
    <link href="/blog/202207181140730603/"/>
    <url>/blog/202207181140730603/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我是把64位文件夹里的文件复制到了STARTUP文件夹中，就可以了。</p></blockquote><p>先搞清楚自己的mathtype是装的32位的还是64位的，以经验来看，装在program files（x86）中是32位的，那么接下来就要去32这个文件夹中找以下三个文件。64位的则去64的文件夹中找！<br>我的是32位的（全是默认安装不知为啥就全是32的了）</p><p>找到<br>C:\Program Files (x86)\MathType\MathPage\32的”MathPage.wll“</p><p>C:\Program Files (x86)\MathType\Office Support\32的”WordCmds.dot“和”MathType Commands 6 For Word 2013.dotm“</p><p>这三个文件。</p><p>把上述3个文件，放置到：C:\Users\用户名\AppData\Roaming\Microsoft\Word\STARTUP</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/chch2010523/article/details/104493225">https://blog.csdn.net/chch2010523/article/details/104493225</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>mathtype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-剑指offerII021-删除链表的倒数第 n 个结点</title>
    <link href="/blog/202207172912652290/"/>
    <url>/blog/202207172912652290/</url>
    
    <content type="html"><![CDATA[<p>双指针：创建dummy虚拟节点；fast指针先走n+1步，因为是要删除倒数第n个节点，所以fast和slow指针一起走，slow指针要指向被删除的节点的前一个节点。</p><p>1刷</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 要删除倒数第n个节点，就要找到倒数第n-1个和倒数第n+1个节点；</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* fast = dummy;<br>        ListNode* slow = dummy;<br><br>        <span class="hljs-comment">// fast 先走n+1步，这样fast和slow一起走，到fast指向null的时候，slow正好走到倒数第n个节点的前一个节点</span><br>        <span class="hljs-comment">// 方便删除第n个节点</span><br>        n++; <span class="hljs-comment">// n加1，下面的fast走n+1步</span><br>        <span class="hljs-keyword">while</span> (n--)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// fast 一直走到 null 为止</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 删除 slow所指向的节点的后面的节点</span><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda创建环境报错</title>
    <link href="/blog/202207161067812127/"/>
    <url>/blog/202207161067812127/</url>
    
    <content type="html"><![CDATA[<p>把.condar的内容改为：</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">channels:<br>  - http:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>  - http:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/conda-forge/</span><br>  - http:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/msys2/</span><br>  - http:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/bioconda/</span><br>  - http:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>show_channel_urls: true<br></code></pre></td></tr></table></figure><p><strong>注意http后面是没有s的</strong></p><blockquote><p>参考：<a href="https://blog.csdn.net/u012961177/article/details/105808889">https://blog.csdn.net/u012961177/article/details/105808889</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试问题记录</title>
    <link href="/blog/20220714289835760/"/>
    <url>/blog/20220714289835760/</url>
    
    <content type="html"><![CDATA[<h2 id="字节群友面经1"><a href="#字节群友面经1" class="headerlink" title="字节群友面经1"></a>字节群友面经1</h2><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220725194458.png"></p><p>sync和reentrantlock的区别<br>sync底层是锁升级的过程，无锁，偏向锁，自旋锁，重量级<br>reetrantlock 底层 是AQS这个类，AQS这个类里面一些操作都是cas操作</p><h2 id="字节群友面经2"><a href="#字节群友面经2" class="headerlink" title="字节群友面经2"></a>字节群友面经2</h2><p>锁升级的整个过程。synchronize的优化，自适应，自旋锁，锁粗化，锁消除啥的。。</p><p>项目 hystrix和分布式事务<br>问了jmm<br>问了tcp怎么保证可靠。</p><p>清华的os b站的<br>6.s081，做了lab<br>极客时间的趣谈linux操作系统<br>极客时间的os45讲 和有个讲内存的课</p><p>答案<br><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/6b45fd6ec8de0d742253f06b0061039.jpg"></p><h2 id="字节提前批面经"><a href="#字节提前批面经" class="headerlink" title="字节提前批面经"></a>字节提前批面经</h2><blockquote><p>作者：想做秋天的风<br>链接：<a href="https://www.nowcoder.com/discuss/985106?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack&amp;page=1">https://www.nowcoder.com/discuss/985106?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack&amp;page=1</a><br>来源：牛客网</p></blockquote><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><ol><li><div class="code-wrapper"><pre><code class="hljs"> http三次握手，状态码，交互细节。</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> 为什么要三次握手</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> 四次挥手，状态码，传输细节，为什么握手要三次，挥手要四次</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> 数据链路层怎么传输数据的，展开说说</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> Arp协议中网关怎么去转换ip地址到对应MAC地址的</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> 如果数据包不在当前子网内，怎么传输到目标子网网关的</code></pre></div></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol start="7"><li><div class="code-wrapper"><pre><code class="hljs"> MySQL的行锁怎么实现的</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> MySQL的事务，展开说说</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs"> MySQL索引了解吗</code></pre></div></li><li><div class="code-wrapper"><pre><code class="hljs">索引是怎么实现的</code></pre></div></li><li><p>索引有哪些，介绍下</p></li><li><p>联合索引中间可以有null值吗，为什么，测试过吗？</p></li><li><p>B+树的特点，原理</p></li><li><p>B+树索引和hash索引的区别，优劣<br>什么是hash索引？区别？优缺点？</p></li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol start="15"><li><p>了解死锁吗</p></li><li><p>MySQL怎么解决死锁的</p></li><li><p>平时遇到过死锁吗，怎么解决的</p></li></ol><h2 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h2><ol start="18"><li><p>JVM的垃圾清除说一下</p></li><li><p>垃圾清除算法有哪些，介绍下</p></li><li><p>知道的垃圾收集器有些什么</p></li><li><p>垃圾的判断方法，引用计数法为什么用的没有GCRoot的多，缺点是什么，为什么</p></li><li><p>平时测试过JVM的垃圾清除吗</p></li></ol><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><ol start="23"><li><p>Redis的了解，介绍下</p></li><li><p>Redis的持久化机制</p></li><li><p>redis怎么实现持久化的</p></li></ol><p>2种，1是快照，2是AOF日志。</p><ul><li>快照：原理是父进程调用fork函数，产生子进程，父子进程共享代码段和数据段；父进程负责处理客户端的请求，子进程进行数据持久化，遍历读取内存数据结构，然后序列化写到磁盘中。<strong>如果父进程接受到客户端的请求，需要修改内存数据结构，这时会用操作系统的写时复制机制进行数据段页面的分离</strong>。父进程会从共享的数据段中复制一份需要修改的页面分离出来，然后对复制的页面进行修改，不会对共享的页面进行修改。也就是说，子进程是感知不到页面的修改的，子进程可以安心的去进行数据持久化的快照操作。其实从子进程产生的时候起，内存数据结构就不会在变化了，这也是为什么叫做快照。</li><li>AOF原理：指令在执行前，先进行校验，然后存储到AOF日志中，再执行指令。如果宕机，只需要吧AOF日志进行指令重放就可以恢复到宕机前的状态。缺点：AOF日志是追加写入，会变的越来越长，重放整个AOF日志会很慢，所以需要对AOF日志进行瘦身。</li><li>混合持久化：先加载快照的内容，然后重放增量AOF日志。该增量AOF日志中保存了从持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小，重放时间较短。</li></ul><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ol start="26"><li>算法题：删除链表的倒数第k个节点</li></ol><p>总结：完全没有问项目问题，计算机网络部分问的特别细！死问我数据链路层的传输原理，答得磕磕绊绊，有好些题都没有答得很好，算法题倒是挺简单的，最后反问，面试官说我答得挺好的，但有些地方细节上还需要再学习优化下。<br>希望可以收到二面的通知！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>四川农行研发实习笔试</title>
    <link href="/blog/20220714944725627/"/>
    <url>/blog/20220714944725627/</url>
    
    <content type="html"><![CDATA[<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>下午14：00-16：30，共两个半小时<br>1.计算机知识选择题<br>    分为几大模块：数据库语句、数据库基础、数据结构、计算机网络、C&#x2F;Java、测试<br>    50分钟写70道选择题，涉及范围广，很多知识点听都没听过，如果有只靠自己能全部写完的人，我特么反正是服了。。。<br>2. 行测<br>    数学推理（5道）、逻辑判断（5道）<br>    10分钟做10道选择题，对于没大量训练过行测的人，写起来很痛苦<br>3.编程题<br>    3道编程题，分为简单、中等和困难。用时90分钟。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>中国农业银行实习生面经</p><p>结构化面试流程：自我介绍+技术面试+综合面试<br>自我介绍（2 min）<br>项目方面 （5 min）<br>技术面试（10-15 min）<br>技术部分一共有两个人进行面试，一个人负责Java基础，另一个人负责数据库以及框架部分<br>Java基础：<br>    1、int占几个字节<br>    2、深拷贝和浅拷贝的区别<br>    3、&#x3D;&#x3D; 与equal的区别<br>    4、线性与非线性的数据结构<br>    5、数据插入的方式（提醒了顺序），让回答别的<br>    6、解释final，finally，finalize的区别<br>    7、Java面型对象的三大特性<br>    8、解释一下什么是泛型<br>数据库与框架<br>    1、以前用过什么框架<br>    2、spring 与springboot的区别<br>    3、#{}与${}的区别，在预编译的时候分别起什么作用<br>    4、内键与外键<br>    5、Springboot的注解<br>综合面试（5min）<br>    1、比赛相对别的队伍优势在哪<br>    2、你负责的是那一部分<br>    3、简单介绍一下这个比赛（互联网+）<br>    4、其他</p><blockquote><p>作者：Morning-Star<br>链接：<a href="https://www.nowcoder.com/discuss/977855?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=082010163EA881CF7BA3CDE559BD38F9-1657798428377">https://www.nowcoder.com/discuss/977855?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=082010163EA881CF7BA3CDE559BD38F9-1657798428377</a><br>来源：牛客网</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发机制的底层实现原理</title>
    <link href="/blog/202207101349528266/"/>
    <url>/blog/202207101349528266/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile的应用和原理"><a href="#volatile的应用和原理" class="headerlink" title="volatile的应用和原理"></a>volatile的应用和原理</h1><h1 id="synchronized-的原理和应用"><a href="#synchronized-的原理和应用" class="headerlink" title="synchronized 的原理和应用"></a>synchronized 的原理和应用</h1><p>synchronized是重量级锁的一个表现形式。</p><p>synchronized 通常被称为重量级锁，因为获得锁和释放锁会进行上下文切换，需要耗费资源，为了减少性能消耗，Java 1.6 引入了偏向锁和轻量级锁，锁的粒度更加地细了，锁会根据需求不断进行升级，直到升级为重量级锁。</p><hr><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><p>Q：<br>多态–》引用—》强软弱虚引用—》</p><p>String对象都存在堆上吗？</p><p>String对象为什么是不可变的？</p><p>final关键字的作用？</p><p>StringBuffer和StringBulder的区别？</p><p>synchronized 的含义？<br>1<br>int i &#x3D; 1;<br>i++;是线程安全的吗？</p><p>计网三次握手 </p><p>HTTP 和 HTTPS的区别</p><p>CA是做什么的？</p><p>MySQL数据库中的事务是什么？<br>从ACID来讲：<br>A原子性：事务的一段操作，要么全部成功，要么全部失败<br>C一致性：例如，A账户向B账户转账，保证AB账户的总额是不变的。无论转账操作进行成功与否。<br>I隔离性：多个事务，b事务对数据库的修改，不干扰a事务的正常运行。<br>D持久性：事务操作会被一些日志文件给记录下来。</p><p>什么是分布式事务呢？你是怎么理解分布式事务的？<br>个人觉得：分布式事务就是 多个服务器，例如主从数据库，在多连接的条件下保证数据的一致性。</p><p>主从数据库的数据是相同的吗？<br>最终的结果，数据是要保证一致的。</p><p>什么是分布式事务中的数据一致性呢？</p><p>如何保证数据的强一致性？</p><p>Spring中的事务传播机制？</p><p>事务的隔离级别：<br>4个级别：<br>读未提交<br>读已提交<br>可重复读<br>事务的串行化：所有的事务来了都要进行排队，如果一条事务A要执行很久，那后面的事务都要排队。</p><p>MySQL用的是可重复读的隔离级别</p><p>可重复读的级别 可以解决 幻读问题吗？<br>先解释一下什么是幻读。<br>个人认为，幻读是指事务A读到的两次读取结果不一样，因为这两次读取之间有事务B往表中新插入insert了一列。</p><p>幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。</p><p>幻读两种情况：select和update读取，快照读和当前读，解决幻读的形式是不一样的。</p><p>不可重复读是 某一条或多条数据的内容前后不一致，但数据条数相同。</p><p>乐观锁：<br>乐观锁认为 进行的操作不会有多线程冲突的。</p><p>悲观锁：<br>认为 每一次操作都会产生线程冲突。</p><p>如何根据具体场景选择乐观锁和悲观锁：<br>读多，用乐观锁。<br>写多，用悲观锁。</p><p>在数据库中设计乐观锁，你会如何设计呢？</p><p>数据库的悲观锁是怎么实现的呢？</p><p>StringBulder的capacity和length的区别</p><blockquote><p>作者：宁愿<br>链接：<a href="https://juejin.cn/post/6844903799534911496">https://juejin.cn/post/6844903799534911496</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于运动电解质相关笔记</title>
    <link href="/blog/202207103760352408/"/>
    <url>/blog/202207103760352408/</url>
    
    <content type="html"><![CDATA[<h2 id="热痉挛"><a href="#热痉挛" class="headerlink" title="热痉挛"></a>热痉挛</h2><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Snipaste_2022-07-09_21-27-17.png"></p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Snipaste_2022-07-09_21-27-26.png"></p><h2 id="热衰竭"><a href="#热衰竭" class="headerlink" title="热衰竭"></a>热衰竭</h2><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Snipaste_2022-07-09_21-28-57.png"></p><h2 id="补充液体的时机"><a href="#补充液体的时机" class="headerlink" title="补充液体的时机"></a>补充液体的时机</h2><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Snipaste_2022-07-09_21-35-59.png"></p><h2 id="在大强度运动中，出汗较多，应该如何补充液体："><a href="#在大强度运动中，出汗较多，应该如何补充液体：" class="headerlink" title="在大强度运动中，出汗较多，应该如何补充液体："></a>在大强度运动中，出汗较多，应该如何补充液体：</h2><p>在运动结束后，需要补充含有碳水化合物和钠的液体；并且液体的浓度不能过高。</p><p><strong>500ML水中，可以放2-3g的盐，20g的糖</strong>，配出来的糖盐水渗透压较低，能够更快的补充身体的水分。盐里的钠离子可以防止大量流汗导致的电解质失衡，糖用来补充碳水化合物。</p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Snipaste_2022-07-09_21-49-42.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-第299场周赛</title>
    <link href="/blog/202206275073044/"/>
    <url>/blog/202206275073044/</url>
    
    <content type="html"><![CDATA[<h2 id="2319-判断矩阵是否是一个-X-矩阵"><a href="#2319-判断矩阵是否是一个-X-矩阵" class="headerlink" title="2319. 判断矩阵是否是一个 X 矩阵"></a><a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/">2319. 判断矩阵是否是一个 X 矩阵</a></h2><p>y总代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkXMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == j || j == n-i<span class="hljs-number">-1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自己的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkXMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历矩阵：判断是否  对角线上元素都不是0，非对角线上元素都是0</span><br>        <span class="hljs-comment">// 判断当前位置是否是对角线</span><br>        <br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == j || j == n-i<span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        res = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] !=<span class="hljs-number">0</span> )<br>                    &#123;<br>                        res = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/blog/202206274266586903/"/>
    <url>/blog/202206274266586903/</url>
    
    <content type="html"><![CDATA[<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f -n 18 file_name<br></code></pre></td></tr></table></figure><ul><li>-f: 监视文件变化</li><li>-n: 读取最后 18 行的文件</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-第81场双周赛</title>
    <link href="/blog/202206252790639376/"/>
    <url>/blog/202206252790639376/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/count-asterisks/">6104. 统计星号</a></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countAsterisks</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;|&#x27;</span>) t++;<br>            <span class="hljs-keyword">if</span> (t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;*&#x27;</span>) cnt ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">6106. 统计无向图中无法互相到达点对数</a><br>无向图，1w个点</p><p>考虑补集<br>不能到达的点对数b &#x3D; Cn2-可以到达的点对数a</p><p>求 有多少个连通块 和 连通块的点数</p><p>每个连通块求下组合数，因为同一个连通块中的任意2个点都可以到达。<br>假设k个连通块中点的数量分别为x1,x2,…xk<br>则k个连通块可以相互到达的点对数量 a &#x3D; C x1 2 + C x2 2 + .. + C xk 2;</p><p>求每个连通块的点数：2类做法<br><strong>图的遍历：</strong><br>DFS<br>BFS<br>并查集：使用并查集维护连通块大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; p; <span class="hljs-comment">// p[x] 是x 的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; cnt; <span class="hljs-comment">// 某个集合中点的数量</span><br><br>    <span class="hljs-comment">// 找 x 的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;   <span class="hljs-comment">// 判断 x 的父节点 p[x] 是否等于自己, 如果是，则 x=p[x]为根节点，直接返回p[x]</span><br>        <span class="hljs-comment">// 如果不是，则继续找p[x]的根节点并返回，即 p[x] = find(p[x])</span><br>        <span class="hljs-keyword">if</span> (p[x] != x) <br>            p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 不连通的数量 = 全集-连通的数量:</span><br>        <span class="hljs-comment">// 不能到达的点对数 = C n 2 - 所有连通块中连通的点对数量(所有连通块中 连通块节点数取2个)</span><br><br>        <span class="hljs-comment">// 求连通块中节点的数量：并查集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        &#123;<br>            p.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// n个节点，每个节点最初是独立的，自己就是根节点</span><br>            cnt.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// cnt表示连通块(集合)中的节点个数</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges)<br>        &#123;<br>            <span class="hljs-type">int</span> a = e[<span class="hljs-number">0</span>], b = e[<span class="hljs-number">1</span>];<br>            a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span> (a != b)<br>            &#123;<br>                <span class="hljs-comment">// 若 a 和 b 不在一个集合中，就计算2个集合中的节点数量之和，并 合并</span><br>                cnt[b] += cnt[a]; <span class="hljs-comment">// 集合的节点个数，只会看集合的根节点x对应的 cnt[find(x)]的数量</span><br>                p[a] = b;<span class="hljs-comment">// a的根节点的父节点是 b的根节点，b的根节点是新的集合的根节点</span><br>            &#125;<br>        &#125;<br><br>        LL res = (LL)n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// *处会爆int</span><br>        <br>        <span class="hljs-comment">// 遍历所有节点，找到每个集合的根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// 这里 p[i]已经是i的根节点了</span><br>            <span class="hljs-comment">// if (p[i] == i) // 节点i的根节点 == i, 即 i 为根节点</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i) == i) <span class="hljs-comment">// 也可以继续使用find(i)找i的根节点</span><br>                res -= cnt[i] * (LL)(cnt[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// * 处会爆int</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-xor-after-operations/">6105. 操作后的最大异或和</a></p><p><a href="https://leetcode.cn/problems/number-of-distinct-roll-sequences/">6107. 不同骰子序列的数目</a><br>dp</p>]]></content>
    
    
    <categories>
      
      <category>leetcode周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分笔记</title>
    <link href="/blog/202206243124902110/"/>
    <url>/blog/202206243124902110/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-16. 最接近的三数之和</title>
    <link href="/blog/202206232865838312/"/>
    <url>/blog/202206232865838312/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h3><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><blockquote><p>输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// x + y + z = target, x+y = target-z, sum = target-z;</span><br>        <span class="hljs-comment">// x + y = sum;</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minv = INT_MAX; <span class="hljs-comment">// 三数之和与target的差值的绝对值 的 最小值</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.<span class="hljs-built_in">size</span>(); a ++)<br>        &#123;<br>            <span class="hljs-comment">// 先找第1个数z=nums[a]，然后转化问题为 求 x + y 接近 sum</span><br>            <span class="hljs-type">int</span> sum = target - nums[a];<br><br>            <span class="hljs-type">int</span> left = a+<span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right)<br>            &#123;<br>                <span class="hljs-comment">// 当前 三数和 与 target 差最小，就更新 minv 和 结果</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(nums[left] + nums[right] - sum) &lt; minv)<br>                &#123;<br>                    minv = <span class="hljs-built_in">abs</span>(nums[left] + nums[right] - sum);<br>                    res = nums[a] + nums[left] + nums[right];<br>                &#125;<br><br>                <span class="hljs-comment">// x + y 尽可能和 sum 接近</span><br>                <span class="hljs-comment">// 如果相等，直接返回 target</span><br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] == sum)<br>                    <span class="hljs-keyword">return</span> target;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &lt; sum) <br>                    left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; sum)<br>                    right--;               <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum-closest">https://leetcode.cn/problems/3sum-closest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-15. 三数之和</title>
    <link href="/blog/202206233583581396/"/>
    <url>/blog/202206233583581396/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code></p><blockquote><p>3刷 2022 07 27</p></blockquote><ul><li>排序</li><li>while循环中去重，是对<code>nums[left]</code>和<code>nums[right]</code>去重</li><li>for循环最后也要去重，是对<code>nums[i]</code>去重</li><li>while中的顺序，先保存三元组到res中，然后双指针收缩，再去重</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</span><br><span class="hljs-comment">*/</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-type">int</span> t = nums[i];<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (left &lt; right)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (t + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) <br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) <br>                    left++;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 保存三元组</span><br>                    vector&lt;<span class="hljs-type">int</span>&gt; tmp = &#123;t, nums[left], nums[right]&#125;;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp);<br>                    <br>                    <span class="hljs-comment">// 找到答案后，双指针同时收缩</span><br>                    left++;<br>                    right--;<br><br>                    <span class="hljs-comment">// 去重</span><br>                    <span class="hljs-comment">// 如果left指针移动后，值仍等于原来的，就说明是重复的值，即 nums[left] = nums[left-1]，应该跳过</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]) right--;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 对num[i]去重</span><br>            <span class="hljs-keyword">while</span> (i &lt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>]) i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>将求 三数之和 转换为 求两数之和，先把数组排序，找第一个数x作为3数中的一个数字，后面只需要找到其他的2个数的和加上这个数x等于0就行。<br>即找到：a+b+x&#x3D;0, a+b &#x3D; -x, 令 sum &#x3D; -x, 则求 a + b &#x3D; sum<br>然后就是求2数之和等于sum了。使用双指针。</p><p>不过要注意重复元素的情况；有三种情况重复,</p><ul><li>nums[left]元素重复，left++后要判断元素是否重复；</li><li>nums[right]元素重复，right–后要判断是否重复；</li><li>nums[a]元素是否重复，要先判断num[a] &#x3D;&#x3D; num[a+1]是否重复，再进行跳过重复元素的操作a++.</li></ul><blockquote><p>2刷 20220623</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.<span class="hljs-built_in">size</span>(); a++)<br>        &#123;<br>            <span class="hljs-type">int</span> sum = -nums[a];<br><br>            <span class="hljs-type">int</span> left = a + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] &lt; sum)<br>                    left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; sum)<br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] == sum)<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; tmp = &#123;nums[a], nums[left], nums[right]&#125;;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp);<br>                    left++;<br>                    right--;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]) right--;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (a + <span class="hljs-number">1</span> &lt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[a] == nums[a+<span class="hljs-number">1</span>]) a++; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><blockquote><p>1刷 20220622</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.<span class="hljs-built_in">size</span>(); a++)<br>        &#123;<br>            <span class="hljs-type">int</span> sum = -nums[a];<br>            <span class="hljs-comment">// 找 两数之和=sum， 使用双指针</span><br><br>            <span class="hljs-type">int</span> left = a + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] &lt; sum) left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; sum) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] == sum)<br>                &#123;<br>                    <span class="hljs-comment">// 把 nums[left], nums[right], nums[a] 保存下来</span><br>                    vector&lt;<span class="hljs-type">int</span>&gt; tmp&#123;nums[left], nums[right], nums[a]&#125;;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp);<br>                    left ++;<br>                    right --;<br>                    <span class="hljs-comment">// 去除重复</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]) right--;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">while</span> (a + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[a] == nums[a+<span class="hljs-number">1</span>])<br>                a++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum">https://leetcode.cn/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-11. 盛最多水的容器</title>
    <link href="/blog/202206222636481904/"/>
    <url>/blog/202206222636481904/</url>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 双指针：left指向首部，right指向尾部</span><br>        <span class="hljs-comment">// 每次考虑如果减少横向距离-1，移动哪个指针？</span><br>        <span class="hljs-comment">// 应该移动 height高度更低的指针，因为面积受限于较低的那个板子。</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right)<br>        &#123;<br>            res = <span class="hljs-built_in">max</span>(res, (right - left) * <span class="hljs-built_in">min</span>(height[left], height[right]));<br><br>            <span class="hljs-keyword">if</span> (height[left] &lt;= height[right]) left ++;<br>            <span class="hljs-keyword">else</span> right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/container-with-most-water">https://leetcode.cn/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-567. 字符串的排列</title>
    <link href="/blog/202206221070769199/"/>
    <url>/blog/202206221070769199/</url>
    
    <content type="html"><![CDATA[<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>样例：<br>输入：s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p><p>y总的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map1, map2;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 判断 c 是否在map1中，且 map1中和map2中c的数量是否相同</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (map1.<span class="hljs-built_in">count</span>(c) &amp;&amp; map1[c] == map2[c])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s1) map1[c]++;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// map1和map2中有多少个柱子相等</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; s2.<span class="hljs-built_in">size</span>(); right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s2[right])) cnt --;<br>            map2[s2[right]]++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s2[right])) cnt ++;<br><br>            <span class="hljs-comment">// 滑动窗口收缩</span><br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; s1.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s2[left])) cnt -- ;<br>                map2[s2[left]] --;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s2[left])) cnt ++ ;<br>                <br>                left++; <span class="hljs-comment">// 滑动窗口左端点收缩</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cnt == map1.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">// cnt 等于 map1的大小</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>没有使用check函数的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map1;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map2;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-comment">// 如何判断 str1 是 str2 的 一个排列呢？</span><br>        <span class="hljs-comment">// 2个字符串一定有着相同的char的出现次数。使用哪种数据结构? 哈希表</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s1) map1[c]++;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示 map1 和 map2 中 有多少个柱子相等</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; s2.<span class="hljs-built_in">size</span>(); right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (map1.<span class="hljs-built_in">count</span>(s2[right]))<br>            &#123;<br>                map2[s2[right]]++;<br>                <span class="hljs-keyword">if</span> (map1[s2[right]] == map2[s2[right]])<br>                    cnt++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; s1.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-comment">// if (map1[left_char]) // map1[key]会创建这个key出来，val默认为0。map[key]只是访问val的一种方式，无法判断是否存在。</span><br>                <span class="hljs-keyword">if</span> (map1.<span class="hljs-built_in">count</span>(s2[left])) <span class="hljs-comment">// 使用count()函数判断key是否存在于map1中</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (map1[s2[left]] == map2[s2[left]])<br>                        cnt --;<br>                    map2[s2[left]]--;<br>                &#125;<br>                left ++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (cnt == map1.<span class="hljs-built_in">size</span>()) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutation-in-string">https://leetcode.cn/problems/permutation-in-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-30. 串联所有单词的子串</title>
    <link href="/blog/202206219051807/"/>
    <url>/blog/202206219051807/</url>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p><p><strong>解法</strong><br>n表示字符串s的长度；<br>m表示words数组中单词的数量；<br>w表示words数组中每个单词的长度，words中每个单词的长度相等，均为words[0]；</p><p>分组的思想：因为words中的每个单词长度相同，所以将字符串根据单词长度w分为 $n&#x2F;w$ 个块。</p><p>双指针：第一个指针<code>i</code>遍历[0,w-1]，对于每个i，指针j每次j+&#x3D;w向后遍历。</p><p>使用2个哈希表，map1 存 words 中的单词的 str–&gt;int 数量，map2 是一个滑动窗口，其中最多只能存 m 个长度为 w 的单词。</p><p>cnt记录 map2 中有多少个单词是map1中的。</p><p>map1使用words数组初始化，比较好理解。<br>map2有 2 个操作，分别是添加单词 word 和删除单词 word：</p><ol><li>窗口满了才删除单词，窗口由[i,j]维护，有m个单词表示窗口满了。将窗口最前面的单词删除，删除后，判断该单词是否是words中的单词，是就把cnt–。</li><li>j&#x3D;0时，就可以像 map2 中添加 word 了，添加的 word 是 s[j, j+w]，添加单词 word 后，也要判断该单词是否是 words 中的单词，是就把cnt++。</li></ol><p>最后，在 map2 中找到 m 个单词在 map1 中时（即cnt&#x3D;&#x3D;m），意味着找到了 words 数组中所有单词，就保存 从 j 向前推 m-1 个单词 的起始位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (words.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), m = words.<span class="hljs-built_in">size</span>(), w = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map1;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> word : words) map1[word]++;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++)<br>        &#123;<br>            unordered_map&lt;string, <span class="hljs-type">int</span>&gt; map2;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录 map2 中有多少个单词是map1中的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j + w &lt;= n; j+=w)<br>            &#123;<br>                <span class="hljs-comment">// 窗口满了，达到了m*w的长度开始删元素</span><br>                <span class="hljs-keyword">if</span> (j - i &gt;= m * w) <span class="hljs-comment">// [i,j]达到了 words数组中的总单词长度</span><br>                &#123;<br>                    <span class="hljs-comment">// 将窗口中前面的word删除</span><br>                    <span class="hljs-keyword">auto</span> word = s.<span class="hljs-built_in">substr</span>(j - m * w, w);<br>                    map2[word]--;<span class="hljs-comment">// 删除</span><br>                    <span class="hljs-keyword">if</span> (map2[word] &lt; map1[word]) cnt --;<br>                &#125;<br>                <br>                <span class="hljs-comment">// [i,j]之间的单词大小 &lt; words的单词总长 m * w</span><br>                <span class="hljs-keyword">auto</span> word = s.<span class="hljs-built_in">substr</span>(j, w);<br>                map2[word]++;<br>                <span class="hljs-keyword">if</span> (map2[word] &lt;= map1[word]) <span class="hljs-comment">// 判断 word 是否是map1中的，即是否是words数组中的单词</span><br>                    cnt ++; <span class="hljs-comment">// 是map1中的单词，就把cnt++，说明找到1个单词</span><br>                <br>                <span class="hljs-comment">// 找到m个单词的时候，即找到words数组中所有单词，就保存字串的起始位置</span><br>                <span class="hljs-keyword">if</span> (cnt == m) res.<span class="hljs-built_in">push_back</span>(j - (m<span class="hljs-number">-1</span>)*w); <span class="hljs-comment">// j和起始位置之间 差了 m-1个单词的距离</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words">https://leetcode.cn/problems/substring-with-concatenation-of-all-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-209-长度最小的子数组</title>
    <link href="/blog/202206211515059335/"/>
    <url>/blog/202206211515059335/</url>
    
    <content type="html"><![CDATA[<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p><strong>思路：</strong><br>双指针，滑动窗口，[j, i] ，判断sum - nums[j] &gt;&#x3D; target来决定是否删除窗口末尾的值.</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针</span><br>        <span class="hljs-type">int</span> res = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            sum += nums[i]; <span class="hljs-comment">// 窗口右端点向右移动1位 </span><br>            <br>            <span class="hljs-comment">// 判断窗口左端点是否可以删除</span><br>            <span class="hljs-keyword">while</span> (sum - nums[j] &gt;= target) &#123;<br>                sum -= nums[j]; <span class="hljs-comment">// 删除窗口最左边的数字</span><br>                j++;<span class="hljs-comment">// 窗口左端点向右移动1位</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (sum &gt;= target) res = <span class="hljs-built_in">min</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在符合条件的子数组，则res的初值从未更新过</span><br>        <span class="hljs-keyword">if</span> (res == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum">https://leetcode.cn/problems/minimum-size-subarray-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 3. 无重复字符的最长子串</title>
    <link href="/blog/202206202878549047/"/>
    <url>/blog/202206202878549047/</url>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><blockquote><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><ul><li>字串是一个连续的序列，子序列可以是不连续的。</li></ul><p><strong>滑动窗口，使用unordered_set<char>作为滑动窗口，使用erace()和insert()函数来删除uset中的元素和插入元素。使用find()查找元素。</char></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; uset;<br><br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (uset.<span class="hljs-built_in">find</span>(s[i]) != uset.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-comment">// 如果 窗口中 有s[i], 就在窗口头删除s[left]，并把left向后移动</span><br>                uset.<span class="hljs-built_in">erase</span>(s[left]); <span class="hljs-comment">// 不能删除s[i]，因为left在移动</span><br>                left++;<br>            &#125;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, i - left + <span class="hljs-number">1</span>);<br>            uset.<span class="hljs-built_in">insert</span>(s[i]); <span class="hljs-comment">// 最后记得把 当前 s[i] 放入窗口中</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxv;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客-加一</title>
    <link href="/blog/202206204287782911/"/>
    <url>/blog/202206204287782911/</url>
    
    <content type="html"><![CDATA[<p>题目：<br>给出用数字数组表示的一个非负整数，请对该整数加1。</p><p>输入：</p><blockquote><p>[1,2,3]</p></blockquote><p>输出：</p><blockquote><p>[1,2,4]</p></blockquote><p>题意：给一个数组，一个数组整体代表一个数字，然后对该数字+1，也就是对数组的最后一个元素+1，其中涉及到了进位的处理。</p><p><strong>核心代码模式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param digits int整型vector </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> carry = num; <span class="hljs-comment">// 保存进位，初始时，进位就是要加的数1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = digits.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        digits[i] += carry; <span class="hljs-comment">// 进行加法操作</span><br>        carry = digits[i] / <span class="hljs-number">10</span>; <span class="hljs-comment">// 求加完后的进位是多少</span><br>        digits[i] = digits[i] % <span class="hljs-number">10</span>; <span class="hljs-comment">// 取模，求去除进位后的数字大小</span><br>    &#125;<br>    <span class="hljs-comment">// 如果最后计算的一位仍有进位1, 就在数组首部插入1</span><br>    <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) <br>        digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>ACM模式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>  LL;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; digits;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        digits.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> carry = num; <span class="hljs-comment">// 进位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = digits.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        digits[i] += carry;<br>        carry = digits[i] / <span class="hljs-number">10</span>;<br>        digits[i] = digits[i] % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果最后计算的一位仍有进位1, 就在数组首部插入1</span><br>    <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>) digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; digits.<span class="hljs-built_in">size</span>() ; i++) cout &lt;&lt;  digits[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客-找出最接近的对称数字</title>
    <link href="/blog/202206203735993444/"/>
    <url>/blog/202206203735993444/</url>
    
    <content type="html"><![CDATA[<p>输入一个正整数的字符串，输出与它最接近的对称数字(不包括它自己)的字符串</p><p>注1: 输入字符串的长度最多不会超过18</p><p>注2: 当大于输入数字和小于输入数字的对称数字与输入数字距离相同时，取小的数字作为答案 </p><p>输入：</p><blockquote><p>123</p></blockquote><p>输出：</p><blockquote><p>121</p></blockquote><p>字符串常用函数：</p><ul><li>reverse(s.begin(),s.end()); 翻转字符串s</li><li>replace(int pos, int len, string str); 用str字符串替换从 pos 起始位置起，长度为len的字符</li><li>substr(int index, int num); 返回从index位置起，长num个字符; 不加第二个参数num则返回从index开始的剩余的字符串。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>  LL;<br><br><span class="hljs-comment">// 判断是否是 1000 这种模式的 字符串</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;1&#x27;</span>) flag = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 33802918 6 96668661</span><br>    <span class="hljs-comment">// 33802918 6 81920833</span><br>    <span class="hljs-comment">// 只需要把前半段的复制到后半段</span><br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <br>    &#123;<br>        cout &lt;&lt; s;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 是1000 类型的</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s))<br>    &#123;<br>        string r = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (r.<span class="hljs-built_in">size</span>() &lt; s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            r += <span class="hljs-string">&quot;9&quot;</span>;<br>        cout &lt;&lt; r;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不是1000类型的</span><br>    string str = s; <br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// cout &lt;&lt; n &lt;&lt; endl;</span><br>    <br>    string substr = s.<span class="hljs-built_in">substr</span>(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; substr &lt;&lt; endl;</span><br>    str.<span class="hljs-built_in">replace</span>(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, n, substr);<br>    <br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/questionTerminal/e605ba77112b425889bee3f40481fe93?answerType=1&f=discussion">参考题解：</a></p><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/e605ba77112b425889bee3f40481fe93">https://www.nowcoder.com/questionTerminal/e605ba77112b425889bee3f40481fe93</a><br>来源：牛客网</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 4482. 分组</title>
    <link href="/blog/202206182942941267/"/>
    <url>/blog/202206182942941267/</url>
    
    <content type="html"><![CDATA[<p>从题目中给出的样例来看，好像找出数组中 相同元素的数量的最大值好像就行。<br>6<br>1 2 4 3 3 2</p><h2 id="使用数组记录，某个元素x出现的次数，求最大的次数"><a href="#使用数组记录，某个元素x出现的次数，求最大的次数" class="headerlink" title="使用数组记录，某个元素x出现的次数，求最大的次数"></a>使用数组记录，某个元素x出现的次数，求最大的次数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> res;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<span class="hljs-comment">//3</span><br>        cin &gt;&gt; x;<br>        a[x] ++;<span class="hljs-comment">//a[3]++;</span><br>        <span class="hljs-keyword">if</span> (a[x] &gt; res) res ++;<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用map记录"><a href="#使用map记录" class="headerlink" title="使用map记录"></a>使用map记录</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> res;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        mp[x].<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 3--&gt; 2个元素</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : mp)<br>    &#123;<br>        res = <span class="hljs-built_in">max</span>(res, (<span class="hljs-type">int</span>) item.second.<span class="hljs-built_in">size</span>());<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing 4483. 格斗场</title>
    <link href="/blog/202206183836283619/"/>
    <url>/blog/202206183836283619/</url>
    
    <content type="html"><![CDATA[<p>一个格斗场内有 n 个战士，其中第 i 个战士的战斗力为 ai。</p><blockquote><p>一个长度为n的数组，第i个数的值为ai</p></blockquote><p>作为格斗场内的经理人，你需要给战士们安排一对一的决斗。</p><blockquote><p>从该数组中挑2个数出来；</p></blockquote><p>这些决斗是一场接一场进行的，一场结束后才会安排下一场。</p><blockquote><p>要保证先从数组中挑2个数出来，处理完了这2个数，才能继续挑下一个“2个数”；</p></blockquote><p>为了保证决斗的观赏性，在安排时需保证：<br>1 决斗双方的战斗力不能相同。</p><blockquote><p>挑的2个数字不能相等，ai !&#x3D; aj， 即 aj - ai &gt;&#x3D; 1</p></blockquote><p>2 决斗双方的战斗力差距不能超过 K。</p><blockquote><p>2个数字差的绝对值要满足 小于等于K：abs(ai - aj) &lt;&#x3D; K</p></blockquote><p>已知，在决斗中战斗力高的选手一定可以将战斗力低的选手击败，并且失败的选手会被赶出格斗场。</p><blockquote><p>if (ai &gt; aj) aj被赶出，ai留下</p></blockquote><p>请你合理安排决斗，使得当剩余选手之间无法再安排任何决斗时，剩余选手的数量越少越好。</p><blockquote><p>要使得剩余的选手数量越少越好，那就是 离开的选手数量越多越好。如果按照上面的规则挑选，那么挑出来的2个数字既不相同，又相差不能大于K，那剩下的选手不能安排任何决斗时，一定是剩下的数字要么相同，要么相差太大。</p></blockquote><p>所以可以先把数组进行排序，然后双指针遍历，能决斗的就决斗，小的走，大的留，minv &#x3D; num.size() - 1;</p><p>7 1 [ n &#x3D; 7, k &#x3D; 1]<br>101 53 42 102 101 55 54<br>sort后:<br>42 53 54 55 101 101 102 </p><blockquote><p>贪心是算法思想，双指针是工具</p></blockquote><p>请你输出剩余选手的最小可能数量minv。</p><h3 id="代码中的a-j-1-a-i-gt-1干了2件事："><a href="#代码中的a-j-1-a-i-gt-1干了2件事：" class="headerlink" title="代码中的a[j-1] - a[i] &gt;= 1干了2件事："></a>代码中的<code>a[j-1] - a[i] &gt;= 1</code>干了2件事：</h3><p>(1) i和j-1不能相同，相同的话，a[i]就是a[j-1]，同一个元素，怎么删除呢。<br>(2) 为了满足题目限制，挑的2个数字不能相同，所以<code>if (a[j-1] != a[i]) res --;</code>也可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a, a + n);<span class="hljs-comment">// 42 53 54 55 101 101 102 </span><br>    <br>    <span class="hljs-type">int</span> res = n;<span class="hljs-comment">// n - t : t是可能要删掉的数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] - a[i] &lt;= k) j++;<br>        <span class="hljs-comment">// 跳出while循环后，此时的 a[j] 是满足 a[j] - a[i] &gt; k 的，则a[j-1]是满足a[j-1] - a[i] &lt;= k的</span><br>        <span class="hljs-keyword">if</span> (i != j<span class="hljs-number">-1</span> &amp;&amp; a[j<span class="hljs-number">-1</span>] - a[i] &gt;= <span class="hljs-number">1</span>) res --; <span class="hljs-comment">// 判断 2个数 是否相等, 如果不相等，就删掉a[i], n(res)-1;</span><br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Acwing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造科研创新点的方式</title>
    <link href="/blog/202206183045971122/"/>
    <url>/blog/202206183045971122/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022-06-25</p></blockquote><p>找他人论文中忽略的信息：</p><p>最近，XXX 在 YYY 很流行，XXX 的优点。<strong>然鹅，这些方法在 AAA 时（后）往往会忽略 BBB 的信息。BBB 怎么样，很重要。</strong>本文提出了一种新颖的基于 CCC 的 MMM 模型，通过 DDD 来 提高 YYY 的性能。</p><hr><p>来源</p><blockquote><p>作者：电光幻影炼金术<br>链接：<a href="https://www.zhihu.com/question/534444001/answer/2512264697">https://www.zhihu.com/question/534444001/answer/2512264697</a></p></blockquote><p>直接上干货。在阅读了100+顶会论文以后，我总结出了以下构造创新点的方式：</p><p>1、化繁为简法：发现过去的文章过于复杂，或者模块过于多，用一个简单本质的办法把过去很难做成的事情做成。</p><p>2、包容并蓄法：把多个文章的优点通过某种方式巧妙地结合起来，互相弥补不足。<br>3、推广应用法：把已有的发现做新场景的应用推广，做的更大更强更好。</p><p>4、弥补不足法：通过对已有的不足场景进行归纳梳理，定义新的问题，提出新的方法加以解决。</p><p>5、天马行空法：构造一个新的任务或者模式，并且通过对比找到解决这一问题的最优方案。</p><p>6、解释演绎法：通过对已有方法的深入分析，演绎出新的结论。然后通过实际场景验证结论是否成立，并且提出新的方法。</p><p>7、考古翻新法：把N年以前的基线方法拿出来，看看是不是能调的更好。往往N年以前的方法+最新的tricks就是最好的。</p><p>8、挖掘比较法：挖掘未发现的影响因子，通过比较建立结果与猜想变量之间的关联。</p><p>题主还有一个问题，如何去寻找创新点，是看文献还是复现别人的结果。我总结了一下寻找创新点的方式：<br>1.多读文献加总结是科研有突破的重要途径。建议从早期的文章开始读，读的时候想象自己穿越回当时，能不能发现问题在哪里，有没有什么新的想法。然后再找后面的文章查对一下，看看自己的想法对不对。通过这种方式促使自己学会发现问题，找到创新点。</p><p>2.多阅读一些专业的审稿意见，训练自己的鉴赏能力。很多未解决的问题都能从审稿意见中发掘出来。欢迎关注我的系列视频栏目「从审稿到中稿」，带大家从审稿意见中发现问题，最终实现中稿。</p><p>3.多读读arxiv，最好培养定期翻看arxiv最新文章的习惯。很多厉害的文章都会先放在arxiv上，而做研究掌握一个好的timing至关重要，早点入局就能抢到先手。另一方面，arxiv上很多文章做的不够好，问题没做完，自己多想想努力一下就能有更好的结果。当然别忘了引用arxiv的文章并讨论区别。</p><p>4.培养自己对科研问题的格局把握，具体说，判断一个问题是三个月之内可以解决的，还是三年可以解决的，还是三十年也解决不了的。不要凭自己的主观臆断来判断，多看看大佬怎么说。如果很多大佬都觉得一个问题三年之内可以解决，并且很有趣，那么就是一个很好的入手问题。</p><p>5.有人说，看到很多论文准确率都很高了，不知道该咋办。这是个新手非常常见的问题，我想引用一个著名的比喻来回答。一个问题的模型，就好比一架很复杂的波音飞机，有几百上千个按钮，有的重要，有的不重要。你现在看到的，就好比看到有那么一架飞机飞的很快。但是更有意义的问题是，你对这架飞机的性能完全了解吗？哪些部分是真正起作用的？能不能造一架更简单但是飞的更快的飞机？如果不能，瓶颈在哪里？这架飞机是不是足够鲁棒，在任何条件下都能飞得很好？</p><p>6.有人说准确率已经很高了，比如说达到了95%。一个事实：如果把5%的错误样本拿出来构成一个数据集，那么它的正确率将是0%。所以关键不在准确率多高，而在失败的样本是不是重要。在真实的自动驾驶或者机器人中，有1%的失误可能会导致很快报废。</p><p>7.永远关注交叉领域或者新领域，并大胆提出新想法。可能新想法会被另一个领域的人爆锤，不要灰心，这是常态，并不要怕碰壁成为作为阻止你学习的理由。不要自己给自己设置壁垒。</p><p>8.可能导师会觉得研究另一个领域会投入很多资源（比如算力或者他开会的时间），但是他挡不住你学习另一个领域的论文。资源可以受限，但是思想不会受限。特别是一个领域的突破性进展，往往可以影响其他领域。降维打击很重要。</p><p>9.把卡住自己的问题记录下来，之后会有意想不到的影响。我跟swin transformer(今年获得了比best paper很难得的马尔奖)的作者聊过，他们是怎么想到swin transformer的？他们说，之前就有想过把self attention替换cnn，但是瓶颈是计算量会大很多，看到谷歌出了vit，算的很快，解决了他们之前的瓶颈，就是self-attention也可以很快还很好，这样他们就产生了swin的想法。</p><p>10.人的创造力是无穷的，科研更多是一种文化，比赛才要刷点。比如同一届的会议有很多论文在imagenet上点数都差不多，但是都各有亮点。百花齐放，百家争鸣，而不要内卷。</p><p>11.多复现一些代码，很多论文都是表面好看，实质代码一跑就有很多问题。</p><p>12.历史是会循环的，旧的领域的突破往往可以适用于新的领域。因此多看看经典论文很有帮助。</p><p>13.要掌握一门到两门可以泛化的，经过大量事实验证有效的方法论。举个例子，比如加速计算的cuda编程等一系列方法，在不同的领域都可以试用。</p><p>14、很多好的idea都是在讨论和碰撞中产生的。尽量多和研究者讨论，方式不限于（1）实验室交流（2）参加讨论会或者研讨会（3）微信群组讨论，可以看评论区加入我的讨论群（4）参加一些国际顶级学术会议，不需要发表论文也可以参加（5）网上看workshop的录像</p><p>15、没有比较就没有伤害，把同一个顶会做同一个任务的论文放到一起，高下立判。</p><p>16、想到什么好的idea，马上去试，不要犹豫。没有不好的idea，只有不明确的idea。</p><p>17、如果单个数据集不能做好，尝试做更多数据集，甚至是跨领域数据集。小数据集上有用的，不一定大数据集有用。</p><p>18、必要的时候翻一翻很久之前的baseline，比如我这篇回答就是很久之前就有的，但是应该有很多人还没看过。时间足够长以后，会发现创新点的寻找远远容易于实验验证，也就是说，只要看的文章足够多，思维应当是远远领先实验的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记记录</title>
    <link href="/blog/202206171550268860/"/>
    <url>/blog/202206171550268860/</url>
    
    <content type="html"><![CDATA[<h1 id="Java题目笔记"><a href="#Java题目笔记" class="headerlink" title="Java题目笔记"></a>Java题目笔记</h1><blockquote><p>2022-06-19更新</p></blockquote><h2 id="Mysql-版本8-0-25-不支持full-join-执行full-join-语句会报错。"><a href="#Mysql-版本8-0-25-不支持full-join-执行full-join-语句会报错。" class="headerlink" title="Mysql(版本8.0.25)不支持full join, 执行full join 语句会报错。"></a>Mysql(版本8.0.25)不支持full join, 执行full join 语句会报错。</h2><blockquote><p>2022-06-17更新</p></blockquote><h2 id="Java权限修饰符："><a href="#Java权限修饰符：" class="headerlink" title="Java权限修饰符："></a>Java权限修饰符：</h2><p><img src="https://uploadfiles.nowcoder.com/images/20180815/6855549_1534301601111_994B36FBA5D0176311889BFCC3F57C1F" alt="图片"><br>private 和 public很容易理解，分别是只能类内部访问和任何地方都可以访问。<br>比较让人容易分不清楚的，默认default的和protected的，默认的权限是类内部和在同一个包下可以访问；保护的权限是类内部、同一个包下和不在同一个包中的子类中可以访问。</p><h2 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h2><p>hashCode()方法并不完全可靠，有时不同对象的hashCode()生成的hash值也是相同的，所以这时候需要再使用equals()来进行比较。</p><p>那为什么不直接都使用equals()进行比较呢？因为重写的equals()方法往往比较复杂，为了提高程序的效率，一般先使用hashCode()进行比较，如果两个对象的hash值不相等，则两个对象肯定不相等，直接返回false；如果hash值相等，则需要再使用equals()进行比较。</p><p>所以，做个总结：</p><ol><li>equals()相等的两个对象，它们的hashCode()肯定相等，使用equals()对比是绝对可靠的。</li><li>hashCode()相等的两个对象，它们的equals()不一定相等。hashCode()不是绝对可靠的。</li></ol><p>正因为hashCode()不是绝对可靠的，所以需要再使用equals()来进行对比。</p><h2 id="关于try、catch、finally的执行顺序"><a href="#关于try、catch、finally的执行顺序" class="headerlink" title="关于try、catch、finally的执行顺序"></a>关于try、catch、finally的执行顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(test());<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(temp); <span class="hljs-comment">// 打印1</span><br>            <span class="hljs-keyword">return</span> ++temp; <span class="hljs-comment">// temp:2, 保存这个值 2</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(temp);<br>            <span class="hljs-keyword">return</span> ++temp;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ++temp; <span class="hljs-comment">//执行finally中的该语句，--&gt; temp:3</span><br>            System.out.println(temp); <span class="hljs-comment">// 打印3</span><br>        &#125; <span class="hljs-comment">// 执行完finally中的语句，打印完3后，再返回到try中的return语句，返回当时保存的值 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的顺序是：</p><ol><li>先打印try中的1，temp加1变为2，保存当前这个值2</li><li>转去执行finally中的语句，temp加1变为3，打印3</li><li>执行完finally后，返回到try中的return语句，返回第1步保存的值2.<br>所以最终的打印顺序是：1, 3, 2</li></ol><p>try中的return的值会被保存到临时空间中，执行完finally后，方法结束，再返回临时空间中保存的值；<br>如果finally中有return temp+10;的话，则会刷新临时空间的值，最后仍返回临时空间的值。</p><hr><p>类的私有变量，本类的方法可以访问，通过反射也可以访问到。</p><h2 id="abstract和final可以同时作为一个类的修饰符吗？"><a href="#abstract和final可以同时作为一个类的修饰符吗？" class="headerlink" title="abstract和final可以同时作为一个类的修饰符吗？"></a>abstract和final可以同时作为一个类的修饰符吗？</h2><p>abstract表示该类是一个抽象类。抽象类本身不能实例化，必须需要有子类继承它并实现抽象类中的所有抽象方法，子类才能实例化。<br>而final表示该类不能被继承。<br>因此这两个关键字的作用：前者表示该类必须被继承，后者表示该类不能被继承，是相克的，不能同时使用。</p><h2 id="当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（service）方法"><a href="#当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（service）方法" class="headerlink" title="当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（service）方法"></a>当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（service）方法</h2><p>HttpServlet容器响应Web客户请求流程如下：<br>1）Web客户向Servlet容器发出Http请求；</p><p>2）Servlet容器解析Web客户的Http请求；</p><p>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；</p><p>4）Servlet容器创建一个HttpResponse对象；</p><p>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；</p><p>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；</p><p>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；</p><p>8）Servlet容器把HttpServlet的响应结果传给Web客户。</p><p>doGet() 或 doPost() 是创建HttpServlet时需要覆盖的方法.</p><h2 id="抽象类和接口不能实例化"><a href="#抽象类和接口不能实例化" class="headerlink" title="抽象类和接口不能实例化"></a>抽象类和接口不能实例化</h2><p>抽象类 a &#x3D; new 子类(); 是可以的。</p><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>如图<br><img src="https://uploadfiles.nowcoder.com/images/20200805/643412545_1596634989327_DEF638F8839D3C558612E08DC0A11BFF" alt="图片"><br>字节流：InputStream, OutputStream</p><p>字符流：多用于处理字符串和文本。面向字符的输入流类都是Reader的子类，面向字符的输出流类都是Writer的子类。一般以 reader 或 writer 结尾。</p><h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><p><a href="https://uploadfiles.nowcoder.com/images/20190314/242025553_1552556718666_11CD8DF4C9693369E94F5F84238EBBC6">JVM图片</a></p><ul><li>PC寄存器</li><li>虚拟机栈</li><li>堆</li><li>方法区 (常量池)</li><li>本地方法栈</li></ul><hr><blockquote><p>2022-06-18</p></blockquote><h2 id="垃圾回收不能确定具体的回收时间"><a href="#垃圾回收不能确定具体的回收时间" class="headerlink" title="垃圾回收不能确定具体的回收时间"></a>垃圾回收不能确定具体的回收时间</h2><p>GC是完全自动的，不能被强制执行。<br>将某个局部变量置为null，只是表示可能会被回收，但是后面可能还会使用。 </p><h2 id="静态代码块、构造代码块和构造方法的执行时期"><a href="#静态代码块、构造代码块和构造方法的执行时期" class="headerlink" title="静态代码块、构造代码块和构造方法的执行时期"></a>静态代码块、构造代码块和构造方法的执行时期</h2><p>1.静态代码块 2.构造代码块3.构造方法的执行顺序是1&gt;2&gt;3;明白他们是干嘛的就理解了。<br>1.静态代码块：是在类的加载过程的第三步初始化的时候进行的，主要目的是给类变量赋予初始值。<br>2.构造代码块：是独立的，必须依附载体才能运行，Java会把构造代码块放到每种构造方法的前面，用于实例化一些共有的实例变量，减少代码量。<br>3.构造方法：用于实例化变量。<br>1是类级别的，2、3是实例级别的，自然1要优先23.<br>在就明白一点：对子类得主动使用会导致对其父类得主动使用，所以尽管实例化的是子类，但也会导致父类的初始化和实例化，且优于子类执行。</p><p>Java程序初始化工作可以在许多不同的代码块中来完成，它们的执行顺序如下：<br><strong>父类</strong>的静态变量、父类的静态代码块、<strong>子类</strong>的静态变量、子类的静态代码块、<br>父类的非静态变量、父类的非静态代码块、父类的构造函数、<br>子类的非静态变量、子类的非静态代码块、子类的构造函数。</p><h2 id="Java构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰；"><a href="#Java构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰；" class="headerlink" title="Java构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰；"></a>Java构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰；</h2><p>识别合法的构造方法；<br>  1：构造方法可以被重载，一个构造方法可以通过this关键字调用另一个构造方法，this语句必须位于构造方法的第一行；<br>    重载：方法的重载(overload)：重载构成的条件：方法的名称相同，但参数类型或参数个数不同，才能构成方法的重载。 </p><p>  2 当一个类中没有定义任何构造方法，Java将自动提供一个缺省构造方法；<br>  3 子类通过super关键字调用父类的一个构造方法；<br>  4 当子类的某个构造方法没有通过super关键字调用父类的构造方法，通过这个构造方法创建子类对象时，会自动先调用父类的缺省构造方法<br>  5 构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰；<br>  6 构造方法不是类的成员方法；<br>  7 构造方法不能被继承。</p><p>  8 java构造方法中的this关键字： 构造器的this指向同一个类中，用于调用同一个类中不同参数列表的另外一个构造器，必须放在第一行，否则会引起编译错误！<br>  9 java构造方法中的super关键字：构造方法的super关键字用于调用其父类的构造方法，子类默认调用父类的构造方法，也就是说super（）是默认调用的，显示调用必须放在构造方法第一行！</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>整数型变量：byte, short, int ,long</strong><br>浮点型：float, double<br>逻辑型：boolean<br>字符型：char</p><h2 id="静态方法中不能直接调用非静态方法和非静态变量"><a href="#静态方法中不能直接调用非静态方法和非静态变量" class="headerlink" title="静态方法中不能直接调用非静态方法和非静态变量"></a>静态方法中不能直接调用非静态方法和非静态变量</h2><p>会在编译时报错：<br>Non-static field ‘a’ cannot be referenced from a static context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-comment">// 非静态变量</span><br>    <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6</span>];<br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(a[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java的反射"><a href="#Java的反射" class="headerlink" title="Java的反射"></a>Java的反射</h2><ul><li>反射涉及的类如：Class在lang包下，Method, Filed 在java.lang.reflet包下。</li><li>通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法。即通过反射实现动态代理。</li><li>通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员。例如：通过反射访问私有成员时，Field调用<code>setAccessible</code>可解除访问符限制。</li><li>反射不能实现对字节码的修改</li><li>Java的反射机制会带来效率问题，使用cache和禁止安全检查等都可以提升反射的效率，但即使再怎么优化也不可能达到和直接调用类一样的效率，因为无论是通过字符串获取Class、Method还是Field，<strong>都需要JVM的动态链接机制动态的进行解析和匹配</strong>（即告诉JVM该如何去找这个类），而直接调用则不必。</li></ul><hr><h1 id="8、面向对象"><a href="#8、面向对象" class="headerlink" title="8、面向对象"></a>8、面向对象</h1><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li>this修饰成员属性</li><li>this修饰成员函数</li><li>this可以在同一个类中调用构造器，this调用构造器必须放在第一行。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>修饰属性</li><li>修饰方法：类的静态方法中不能访问非静态方法和非静态属性。</li><li>修饰代码块：执行顺序，<strong>静态块–》构造块–》构造器–》成员方法中的普通块</strong>。注意：静态块只在类加载的时候执行一次。<strong>静态块中只能访问静态成员变量和静态成员方法</strong>，不能访问非静态成员方法和非静态成员方法。</li><li>修饰内部类：</li></ul><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>提高代码的安全性</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>提高代码的复用性</p><p>父类private修饰的内容，子类实际上也继承，只是因为封装的特性阻碍了直接调用，但是提供了间接调用的方式，可以间接调用。</p><h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><blockquote><p>总结：<br>属性，方法：修饰符：四种：private，缺省，protected，public<br>类：修饰符：两种：缺省，public</p><p>以后写代码<br>一般属性：用private修饰 ，方法：用public修饰</p></blockquote><h4 id="重载和重写的区别："><a href="#重载和重写的区别：" class="headerlink" title="重载和重写的区别："></a>重载和重写的区别：</h4><p>重载：在同一个类中，当方法名相同，形参列表不同的时候  多个方法构成了重载<br>重写：在不同的类中，子类对父类提供的方法不满意的时候，要对父类的方法进行重写。</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>toString方法</p><p>equals方法</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>提高代码的扩展性</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>修饰基本数据类型，变量值不能改变，是一个常量。</p><p>修饰引用数据类型，对象的引用，也就是对象的指向不能改变，对象的属性可以修改。</p><p>修饰方法，该方法不能被该类的子类重写。</p><p>修饰类，表示该类不能被继承，也就是没有子类。</p><h3 id="抽象类，抽象方法"><a href="#抽象类，抽象方法" class="headerlink" title="抽象类，抽象方法"></a>抽象类，抽象方法</h3><ul><li>抽象类是否可以创建对象？</li></ul><p>不可以</p><ul><li>抽象类中是否有构造器？</li></ul><p>有的。子类创建对象初始化时调用子类的构造器，会先使用super调用抽象类的构造器。</p><ul><li>抽象类是否可以被<code>final</code>修饰？</li></ul><p>不能，因为抽象类就是用于被继承的，<code>final</code>修饰的类不能被继承，就没有子类了。</p><p>需要被子类重写的方法加上<code>abstract</code>，去除函数体，就是抽象方法了，抽象方法必须要被子类重写。</p><p>子类如果没有重写父类的全部抽象方法，那么子类也可以变成一个抽象类。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h4><table><thead><tr><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>使用abstract修饰</td><td>使用interface修饰</td></tr><tr><td>不能实例化</td><td>不能实例化</td></tr><tr><td>有构造方法</td><td>无构造方法</td></tr><tr><td>含有抽象方法的类是抽象类，必须使用abstract修饰</td><td>一个类只能继承一个类，但是可以实现多个接口</td></tr><tr><td><strong>可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法</strong></td><td>接口中的方法均为抽象方法</td></tr><tr><td>若子类实现了抽象类的所有抽象方法，则子类不是抽象类；否则子类是抽象类</td><td>接口中不能包含<strong>实例域或静态方法</strong>（静态方法必须实现，而接口中都是抽象方法，不能实现）</td></tr></tbody></table><blockquote><p>Package ‘com.xxx.demo12’ clashes with class of same name</p><p>爆红：包名与类名冲突</p></blockquote><h4 id="JDK1-8前后接口的变化"><a href="#JDK1-8前后接口的变化" class="headerlink" title="JDK1.8前后接口的变化"></a>JDK1.8前后接口的变化</h4><table><thead><tr><th>JDK1.8前，接口仅包含常量和抽象方法</th><th>JDK1.8后，接口新增非抽象方法（可以有函数体）</th></tr></thead><tbody><tr><td>常量：public static final</td><td>常量：public static final</td></tr><tr><td>抽象方法：public abstract</td><td>抽象方法：public abstract</td></tr><tr><td></td><td>非抽象方法：public <strong>default</strong></td></tr><tr><td></td><td>实现类要想重写非抽象方法，那么default修饰符不能加</td></tr><tr><td></td><td><strong>静态方法：</strong>public <strong>static</strong></td></tr><tr><td></td><td>static不能省略；静态方法不能在实现类重写</td></tr></tbody></table><h4 id="为什么要在接口中加入非抽象方法？"><a href="#为什么要在接口中加入非抽象方法？" class="headerlink" title="为什么要在接口中加入非抽象方法？"></a>为什么要在接口中加入非抽象方法？</h4><p>Java 8新增了default方法，它可以在接口添加新功能特性，而且还不影响接口的实现类。</p><p>Q：在面向接口编程的过程中，如果<strong>发现原有的接口中，都需要添加一个相同的方法</strong>，有两种实现方案：</p><ol><li>把接口换成抽象类，在抽象类中添加该方法（需要改动代码）</li><li>在接口中添加该抽象方法，在每一个接口的实现类中，都要添加相同的实现方法，代码的改动是相当大的。</li></ol><p>两种方法对代码的改动都是很大的。<strong>如果使用接口的默认方法，是接口本身就拥有某些功能的实现，就很好的解决了问题。</strong></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类：静态成员内部类，非静态成员内部类</p><p>局部内部类：（方法中，块中，构造器中）</p><p>匿名内部类</p><h1 id="9、异常"><a href="#9、异常" class="headerlink" title="9、异常"></a>9、异常</h1><p>Error：错误</p><p>Exception：</p><ol><li>检查异常</li><li>运行时异常</li></ol><img src="/blog/.io//202206171550268860/image-20220518125702351.png" class title="异常分类"><h1 id="10、常用类"><a href="#10、常用类" class="headerlink" title="10、常用类"></a>10、常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>自动装箱，自动拆箱</p><p>日期类</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>不可变的，底层实现是<code>final char value[]</code>也是数组，不过是final的。</p><h2 id="StringBuider类，StringBuffer类"><a href="#StringBuider类，StringBuffer类" class="headerlink" title="StringBuider类，StringBuffer类"></a>StringBuider类，StringBuffer类</h2><p>StringBuider的底层实现是数组<code>char value = new char[capacity];</code>，可变数组，可以动态扩容，最初数组容量为16，一旦向里面加入的字符串的长度大于16时，就会扩容，扩容规则为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">value = Arrays.copyOf(value,<br>                    newCapacity(minimumCapacity));<br>调用下面的方法：<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;<span class="hljs-comment">// 扩容逻辑</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minCapacity;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)<br>            ? hugeCapacity(minCapacity)<br>            : newCapacity;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="StringBuider类，StringBuffer类的区别？"><a href="#StringBuider类，StringBuffer类的区别？" class="headerlink" title="StringBuider类，StringBuffer类的区别？"></a>StringBuider类，StringBuffer类的区别？</h4><p>底层都是可变char数组，区别是StringBuilder是线程不安全的，效率高；StringBuffer是线程安全的，效率低。</p><p>StringBuffer的大多数方法都加了<code>synchronized</code>关键字，上了锁，所以效率低，一般优先考虑使用StringBuilder。</p><h1 id="11、集合"><a href="#11、集合" class="headerlink" title="11、集合"></a>11、集合</h1><h2 id="1、Collection接口"><a href="#1、Collection接口" class="headerlink" title="1、Collection接口"></a>1、Collection接口</h2><p>——List接口：实现类有，ArrayList，LinkedList</p><p>——Set接口：实现类有, HashSet, TreeSet</p><p>ArrayList实现类：</p><p>在jdk1.7中，数组初始默认容量为10,</p><p>数组的扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>扩容1.5倍。原容量为10，新容量为15；</p><p>在jdk1.8中，调用空构造器，底层数组初始化为{}，数组容量最初为0，然后变为10；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jdk1.8</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>Vector容器，底层扩容数组长度为原来2倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ? <span class="hljs-comment">// capacityIncrement=0</span><br>                                 capacityIncrement : oldCapacity);<br><span class="hljs-comment">// int newCapacity = oldCapacity + oldCapacity</span><br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><p>元素的类型参数叫做泛型</p></blockquote><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2、Map接口"><a href="#2、Map接口" class="headerlink" title="2、Map接口"></a>2、Map接口</h2><h3 id="HashMap原理及内部存储结构"><a href="#HashMap原理及内部存储结构" class="headerlink" title="HashMap原理及内部存储结构"></a>HashMap原理及内部存储结构</h3><p><a href="https://juejin.cn/post/6844903763715555336#comment">https://juejin.cn/post/6844903763715555336#comment</a></p><h3 id="HashMap源码线程安全性问题（1-8）"><a href="#HashMap源码线程安全性问题（1-8）" class="headerlink" title="HashMap源码线程安全性问题（1.8）"></a>HashMap源码线程安全性问题（1.8）</h3><h4 id="1-多线程的map-put-方法可能导致元素的丢失："><a href="#1-多线程的map-put-方法可能导致元素的丢失：" class="headerlink" title="1 多线程的map.put()方法可能导致元素的丢失："></a>1 多线程的map.put()方法可能导致元素的丢失：</h4><p>实验代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentIssueDemo1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1 =&gt; t1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">99999999</span>; i++) &#123;<br>                    map.put(<span class="hljs-string">&quot;thread1_key&quot;</span> + i, <span class="hljs-string">&quot;thread1_value&quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">// 线程2 =&gt; t2</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">99999999</span>; i++) &#123;<br>                    map.put(<span class="hljs-string">&quot;thread2_key&quot;</span> + i, <span class="hljs-string">&quot;thread2_value&quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>触发此问题的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>; <span class="hljs-comment">// 树化阈值=8</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// 初始化hash表tab，定义一个p，Node类型的</span><br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>    <br>    <span class="hljs-comment">// 通过hash值计算在hash表tab中的位置，并将这个位置上的元素赋值给p，如果该位置上为null，</span><br>    <span class="hljs-comment">// 则new一个新的node放在该位置。</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果hash表中已经存在元素，就向该元素后面追加链表</span><br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;  <span class="hljs-comment">// 判断是否和已存在的元素相同</span><br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-comment">// 新建节点，并追加到链表</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// #1，在此处t1和t2两个线程同时执行完</span><br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>); <span class="hljs-comment">// #2 </span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>两个线程t1和t2同时执行到上述代码的注释<code>#1</code>处，然后一起向下执行，</p><p>t1线程执行map.put(“key2”, “value2”)，t2线程执行map.put(“key3”, “value3”)，</p><p>假设t1先执行<code>p.next = newNode(hash, key, value, null)</code>，那么会新建节点key2，并追加链表；</p><p>然后t2也执行<code>p.next = newNode(hash, key, value, null)</code>， 就会将<code>p.next</code>重新指向一个新的节点key3，</p><p>p.next原来指向的节点key2就丢失了。</p><p>这样就产生了<strong>线程安全问题</strong>。</p><h4 id="2-put和get并发时，可能导致get为null"><a href="#2-put和get并发时，可能导致get为null" class="headerlink" title="2 put和get并发时，可能导致get为null"></a>2 put和get并发时，可能导致get为null</h4><p>场景：</p><p>当线程1执行put方法时，如果元素个数超出threshold需要扩容导致rehash，</p><p>线程2此时执行get方法，就由可能导致get得到的值为null。</p><p>扩容resize()方法源码：</p><p>先计算出扩容后的容量和threshold，然后根据新容量创建新hash表，然后将旧hash表中的元素rehash到新的hash表中。</p><p>重点在于<strong>创建新hash表和hash表赋值的两句代码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 上面就是得到 新的容量newCap 和 threshold newThr</span><br>    <br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap]; <span class="hljs-comment">// #1</span><br>    table = newTab; <span class="hljs-comment">// #2</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        ...... <span class="hljs-comment">// 将旧hash表中的元素rehash到新hash表中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码#1位置，使用新的容量newCap创建新hash表newTab，</p><p>然后在#2的位置将新hash表赋值给变量table。</p><p>赋值完后，table是空的！</p><p>如果此时，有线程使用get方法获取值，会得到null。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>Collections工具类</p><p>Stack</p><p>Queue</p><p>Deque</p><p>并发容器</p><p>ConcurrentMap</p><h1 id="多线程-并发"><a href="#多线程-并发" class="headerlink" title="多线程 并发"></a>多线程 并发</h1><p>线程常见方法：</p><ul><li><p>join方法：当一个线程调用了join方法，这个线程就会先被执行，它执行结束以后才可以去执行其余的线程。<br>注意：必须先start，再join才有效。</p></li><li><p>setDaemon(true)方法; 将子线程设置为主线程的伴随线程，主线程停止，子线程也停止执行</p></li></ul><p>线程安全问题：</p><p>竞争资源引发的，加锁</p><p>1、同步代码块</p><p>2、同步方法</p><p>3、Lock</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>项目：</p><p>spring 原理</p><p>spring mvc 原理</p><p><strong>项目名称</strong>：仿<a href>牛客</a>论坛项目</p><p><strong>技术选型</strong>：SpringBoot+MySQL+Redis +Kafka+Elasticsearch</p><p><strong>项目描述</strong>：本项目采用微服务架构的思想，主要涉及模块有权限模块、核心模块、性能模块、通知模块、搜素模块和其他模块。完成了xx模块后台代码的编写，解决了帖子审核、评论、异常等功能的开发，从中学习到了xx技术栈等【这里可以挑选几个自己比较熟悉的模块写上去】</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Colab 脚本</title>
    <link href="/blog/202206152609411500/"/>
    <url>/blog/202206152609411500/</url>
    
    <content type="html"><![CDATA[<p>谷歌Colab点击脚本<br>F12进入浏览器控制台</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClickConnect</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked on connect button&quot;</span>); <br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;paper-button&quot;</span>).<span class="hljs-title function_">click</span>()<br>&#125;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-title class_">ClickConnect</span>,<span class="hljs-number">60000</span>)<br></code></pre></td></tr></table></figure><p>停止脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> <span class="hljs-title class_">ClickConnect</span>(id_of_ClickConnect)<br></code></pre></td></tr></table></figure><p><code>id_of_ClickConnect</code>是执行 setInterval() 时返回的 ID 值</p>]]></content>
    
    
    
    <tags>
      
      <tag>Colab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka笔记</title>
    <link href="/blog/202206132043560161/"/>
    <url>/blog/202206132043560161/</url>
    
    <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。</p><p>实现高性能，高可用，可伸缩和最终一致性架构。</p><p>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。</p><p>kafka是消息队列的一种，<strong>那为什么要用消息队列呢？</strong></p><h1 id="用消息队列有什么好处呢？"><a href="#用消息队列有什么好处呢？" class="headerlink" title="用消息队列有什么好处呢？"></a><strong>用消息队列有什么好处呢？</strong></h1><h2 id="系统之间-解耦"><a href="#系统之间-解耦" class="headerlink" title="系统之间 解耦"></a>系统之间 解耦</h2><p>消息队列存放 其他系统所需要的数据，其他系统可能有很多个，可能有的需要，有的不需要，也可能有的系统现在需要，过段时间又不需要了。</p><h2 id="系统之间-异步"><a href="#系统之间-异步" class="headerlink" title="系统之间 异步"></a>系统之间 异步</h2><p>主系统把 <strong>有用的消息或数据</strong> 放到消息队列中<strong>就可以直接返回</strong>了，<strong>提高用户体验和吞吐量</strong>。</p><h2 id="用户和系统之间-削峰"><a href="#用户和系统之间-削峰" class="headerlink" title="用户和系统之间 削峰"></a>用户和系统之间 削峰</h2><p>多用户，高并发请求，系统处理不过来。</p><p>可以 把用户的请求都 放到消息队列中，然后呢，每个系统根据自己能够处理的请求的数量，去MQ中拿请求进行处理。</p><p>不过有个问题，就是MQ的消息积压了怎么办？</p><p>这就要考虑到消息队列会面临什么问题？</p><h2 id="1-高可用"><a href="#1-高可用" class="headerlink" title="1 高可用"></a>1 高可用</h2><p>消息队列要分布式部署，也就是要有多台MQ服务器</p><h2 id="2-数据丢失问题"><a href="#2-数据丢失问题" class="headerlink" title="2 数据丢失问题"></a>2 数据丢失问题</h2><p>系统还没有来得及消费数据，MQ就挂掉了，那如何持久化消息呢？</p><p>3 消息重复消费问题</p><p>消息积压问题</p><p><a href="https://zhuanlan.zhihu.com/p/55712984">https://zhuanlan.zhihu.com/p/55712984</a></p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NzA3MTc5Mg==&amp;action=getalbum&amp;album_id=2137264927726764033&amp;scene=173&amp;from_msgid=2247485877&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NzA3MTc5Mg==&amp;action=getalbum&amp;album_id=2137264927726764033&amp;scene=173&amp;from_msgid=2247485877&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令记录</title>
    <link href="/blog/20220609340547489/"/>
    <url>/blog/20220609340547489/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>以当前的快照为基础，创建一个新的快照</p><p>git commit</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>创建分支，就是创建一个指针 newImage，指向当前的快照</p><p>git branch ‘newImage’</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout ‘分支名字’<br>切换分支并提交<br>git checkout ‘newImage’; git commt</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ol><li>git merge<br>当前在 main 分支，还有一个 bugFix 分支，使用 <code>git merge bugFix</code> 把 bugFix 合并到 main 里</li></ol><p>切换到 bugFix 分支， 把 main 分支合并到 bugFix 分支：<br><code>git checkout bugFix; git merge main</code></p><ol start="2"><li>git rebase<br>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。<br>将 bugFix 分支的内容移动到 main 分支后面，<br>先切换到 bugFix 分支，然后 <code>git rebase main</code>；</li></ol><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><p>在提交树上移动<br>git checkout c4</p><h3 id="相对引用-改变HEAD的指向"><a href="#相对引用-改变HEAD的指向" class="headerlink" title="相对引用:改变HEAD的指向"></a>相对引用:改变HEAD的指向</h3><ol><li>使用 <code>^</code> 向上移动一个提交记录；</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，例如：<code>~3</code></li></ol><p><code>main^</code>相当于 找 main 的父节点：<code>git checkout main^</code><br><code>git checkout HEAD^</code></p><p>“~”操作符<br>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。<br>该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p><p>git checkout HEAD~4:后退4步</p><h3 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:<br>git branch -f main HEAD~3</p><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p><p><code>git branch -f main HEAD~3</code> 命令可以让 mian 去指定的位置</p><h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>一是 git reset，还有就是 git revert。</p><p>本地使用 git reset HEAD~1:回退1个</p><p>为了撤销更改并分享给别人，我们需要使用 git revert。<br>revert 会创建一个新的提交，这个新的提交和上上个提交是一样的。<br>git revert HEAD<br>revert 后，可以把更改推送到远程仓库了。</p><h1 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h1><p>到现在我们已经学习了 Git 的基础知识 —— 提交、分支以及在提交树上移动。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求</p><p>然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p><h2 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h2><p>本系列的第一个命令是 git cherry-pick, 命令形式为:</p><p><code>git cherry-pick &lt;提交号&gt;...</code><br>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，<br>Cherry-pick 是最直接的方式了。我个人非常喜欢 cherry-pick，因为它特别简单。</p><p>当前在 main 分支，执行 <code>git cherry-pick c2 c4</code>,  将 side 分支的 c2和c4复制到当前 main 分支下面；</p><h2 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h2><p><strong>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时</strong>,<br>用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p><p>但是<strong>如果你不清楚你想要的提交记录的哈希值呢?</strong> 幸好 Git 帮你想到了这一点,<br>我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录,<br>这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i</p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，<br>它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。<br> 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。</p><p><code>git rebase -i HEAD~4</code><br>可以选择复制的节点快照</p><p>在 main 分支，执行 <code>git rebase -i HEAD~4</code>, 选择要复制的节点快照和顺序;</p><hr><h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><h4 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h4><h4 id="新建本地仓库，git-test"><a href="#新建本地仓库，git-test" class="headerlink" title="新建本地仓库，git-test"></a>新建本地仓库，git-test</h4><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> git-test<br></code></pre></td></tr></table></figure><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h4 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h4><p><code># git remote add origin(默认origin，可修改) branch_Name(为空时默认为master) url</code></p><p>两个地方的仓库名不需要相同，因为通过在本地仓库目录下执行这条命令（命令中包含远程库的名字）已经将两者建立了联系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.xxx/xxx.git<br></code></pre></td></tr></table></figure><h4 id="创建文件，修改文件"><a href="#创建文件，修改文件" class="headerlink" title="创建文件，修改文件"></a>创建文件，修改文件</h4><h4 id="添加所有文件到本地库"><a href="#添加所有文件到本地库" class="headerlink" title="添加所有文件到本地库"></a>添加所有文件到本地库</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> *<br></code></pre></td></tr></table></figure><h4 id="提交文件到本地库"><a href="#提交文件到本地库" class="headerlink" title="提交文件到本地库"></a>提交文件到本地库</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交日志&quot;</span><br></code></pre></td></tr></table></figure><h4 id="将本地库的所有内容推送到远程库上"><a href="#将本地库的所有内容推送到远程库上" class="headerlink" title="将本地库的所有内容推送到远程库上"></a>将本地库的所有内容推送到远程库上</h4><p>加上了-u参数(推送和关联)，Git不但会把本地的master分支内容推送到远程新的master分支，</p><p>还会把本地的master分支和远程的master分支关联起来</p><p>以后即可直接用git push代替git push origin master</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>来源：<a href="https://zhuanlan.zhihu.com/p/87732909">https://zhuanlan.zhihu.com/p/87732909</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库笔记</title>
    <link href="/blog/202206052864324003/"/>
    <url>/blog/202206052864324003/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>MySQL技术内幕 InnoDB</p></blockquote><h3 id="数据库为什么要引入事务？"><a href="#数据库为什么要引入事务？" class="headerlink" title="数据库为什么要引入事务？"></a>数据库为什么要引入事务？</h3><p>事务可以把数据库从一种 一致状态 转换为 另一种一致状态。<br>在数据库提交工作时，可以确保要么所有修改都保存了，要么所有的修改都不保存。</p><h3 id="知道事务的四大特征吗？（基础）"><a href="#知道事务的四大特征吗？（基础）" class="headerlink" title="知道事务的四大特征吗？（基础）"></a>知道事务的四大特征吗？（基础）</h3><p>ACID：原子性，一致性，隔离性和持久性。</p><p>原子性 Atomicity：指整个数据库事务是不可分割的工作单位，要么全都做，要么全都不做；</p><p>一致性 consistency：指事务将数据库从一种状态转变为下一种一致的状态。<br><strong>指事务执行前后，数据处于一种合法的状态；</strong>事务是一致性的单位，如果事务中某个动作失败了，<br>系统可以自动撤销事务————返回初始化的状态。</p><p>隔离性 isolation：隔离性也称为 并发控制、可串行化、锁等。<br>事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即<br>该事务提交前对其他事务都不可见，<strong>通常这使用锁来实现</strong>。<br>指并发执行的各事务之间互不影响，相互隔离；</p><p>持久性 durability：事务一旦提交，对数据库的改变是永久性的。即使发生宕机等故障，<br>数据库也能将数据恢复。</p><blockquote><p>好，既然你知道4大特性，那你讲讲 MySQL 如何实现的呢？</p></blockquote><h3 id="事务的一致性的如何保证的？（追问）"><a href="#事务的一致性的如何保证的？（追问）" class="headerlink" title="事务的一致性的如何保证的？（追问）"></a>事务的一致性的如何保证的？（追问）</h3><ol><li>数据库层面：<strong>通过原子性，隔离性和持久性来保证的</strong>，原子性、隔离性和持久性是手段，<br>一致性是目的。</li><li>应用层面：通过判断数据是否符合业务规则、数据库操作是否报错，是否符合预期等，来决定<br>是回滚事务 or 提交事务来满足一致性要求。</li></ol><p>事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的 redo log 和 undo log 来完成。</p><ul><li>redo log 称为重做日志，用来保证事务的持久性。</li><li>undo log 是回滚日志，用来保证事务的原子性。作用是帮助事务回滚和实现MVCC。<br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1659861790&ver=3967&signature=heoQ1jLP1Gy9Qkm*fwXqdeyd9A8XLw-WrSzaTdqV7DJKCzuaYWcwhudl37QewUSCW3f8GDFgMSewwNVkYu8cAjva9uRMmTPZ5mx6MtbpeldGKE6U5rTl4XL3ZvmxfUXm&new=1">MySQL三大日志(binlog、redo log和undo log)的作用了解吗？</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1659861790&ver=3967&signature=9PDRdZkjHbkQP6UN45ySlL9B4jcYtOtOhVZKpNowUdlZGqczfuaX04M0APtSjsTh3hTUlTNZuG*QzTx-yeMFTpPUcSMe0WDXWTzWlQwvNmAOYF3-eodw4eCJdTI*ouz-&new=1">精讲 MySQL 事务日志：redo log 和 undo log</a></li></ul><h3 id="事务的原子性是如何保证的呢？"><a href="#事务的原子性是如何保证的呢？" class="headerlink" title="事务的原子性是如何保证的呢？"></a>事务的原子性是如何保证的呢？</h3><p>undo log 是实现原子性的关键。<br>undo log 是回滚日志，当事务执行到一半失败时，撤销所有已经成果执行的SQL语句，需要<br>回滚日志的信息，利用 undo log 中的信息将数据回滚到修改之前的样子。</p><h3 id="一条查询语句的执行流程？"><a href="#一条查询语句的执行流程？" class="headerlink" title="一条查询语句的执行流程？"></a>一条查询语句的执行流程？</h3><h3 id="一条更新语句的执行流程？"><a href="#一条更新语句的执行流程？" class="headerlink" title="一条更新语句的执行流程？"></a>一条更新语句的执行流程？</h3><blockquote><p>更深</p></blockquote><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><ol><li><p>能讲讲 MySQL 中有哪些索引类型吗？</p><blockquote><p>索引类型分为几个维度。<br>一种叫聚簇索引，是物理索引，数据表就是按顺序存储的，物理上是连续的；<br>还有一种叫非聚簇索引。<br>从物理存储角度，分为聚簇索引和非聚簇索引。吧啦吧吧…<br>从可见性角度，分为可见索引和非可见索引。巴拉巴拉…</p></blockquote></li><li><p>主键是聚簇索引吗？</p></li><li><p>如果创表时没有手动指定主键还有聚簇索引吗？</p></li><li><p>如果有多个唯一索引选择哪个作为聚集索引？</p></li></ol><hr><h2 id="MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？"><a href="#MySQL-为什么使用-B-树来作索引，对比-B-树它的优点和缺点是什么？" class="headerlink" title="MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？"></a>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</h2><p>优点：</p><p>多叉搜索树，每个非叶子节点放的索引数量更多，树的高度更低，查找某个叶子节点的数据所要进行的IO次数就更少。</p><p>使用B+树，在大数据量的情况下，进行范围查找的效率更高，把数据都放在叶子节点，叶子节点直接使用双向链表进行链接，方便范围查找。</p><p>缺点：</p><p>不管查询什么数据，都要下到叶子节点才能得到数据；对于数据量较少的情况，使用B树效率更高，因为B树的数据和索引是放在一起的，不用非要下到叶子节点才能得到数据。</p><h2 id="数据库的事务隔离级别有哪些？各有哪些优缺点？"><a href="#数据库的事务隔离级别有哪些？各有哪些优缺点？" class="headerlink" title="数据库的事务隔离级别有哪些？各有哪些优缺点？"></a>数据库的事务隔离级别有哪些？各有哪些优缺点？</h2><p><a href="https://zhuanlan.zhihu.com/p/117476959">https://zhuanlan.zhihu.com/p/117476959</a></p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="缓存雪崩-缓存击穿-缓存穿透"><a href="#缓存雪崩-缓存击穿-缓存穿透" class="headerlink" title="缓存雪崩 缓存击穿 缓存穿透"></a>缓存雪崩 缓存击穿 缓存穿透</h2><ul><li>缓存雪崩：大量key同时失效；【随机设置key过期时间】【熔断机制】【数据库容灾能力，分库分表，读写分离】【Redis集群】</li><li>缓存击穿：某一热点key突然失效；【热点key不设置过期时间】【互斥锁，获取锁才能访问数据库】</li><li>缓存穿透：大量不存在于Redis中的key，穿过了缓存，打在了数据库上。【使用布隆过滤器】</li></ul><p><a href="https://zhuanlan.zhihu.com/p/346651831">https://zhuanlan.zhihu.com/p/346651831</a></p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>作用：</p><p>如果某个key不存在，那就一定不存在；如果某个key存在，那么很大可能是存在（有一定的误判率）；</p><p>在缓存前加一层布隆过滤器，如果判断key一定不存在，就直接返回；如果判断key存在，再查Redis和数据库。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线性与并发笔记</title>
    <link href="/blog/202206021815796968/"/>
    <url>/blog/202206021815796968/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-进程-线程"><a href="#1-进程-线程" class="headerlink" title="1.进程 线程"></a>1.进程 线程</h1><p>进程让操作系统的并发性成为可能；而线程让进程的内部并发成为可能。</p><p>一个进程包括多个线程，但是这些线程共同享有进程的资源和地址空间。</p><p>进程是操作系统进行资源分配的基本单位，而线程是操作系统调度的基本单位。</p><h1 id="2-多线程并发"><a href="#2-多线程并发" class="headerlink" title="2.多线程并发"></a>2.多线程并发</h1><h2 id="性能问题："><a href="#性能问题：" class="headerlink" title="性能问题："></a>性能问题：</h2><p>对于单核CPU：</p><ul><li><p>CPU密集型任务，如解压文件，一直占用CPU，单线程比多线程性能高，因为多线程涉及到线程切换，线程切换导致的开销可能会让性能下降。</p></li><li><p>交互任务型任务，当然是多线程比单线程性能高。</p></li></ul><p>对于多核CPU：</p><ul><li>对于CPU密集型任务，多线程优于单线程，因为能更充分的利用多核资源。</li></ul><p>多线程编程能够提升程序性能，但是编程复杂，需要考虑线程安全问题。</p><h1 id="3-如何创建线程？创建线程的方法"><a href="#3-如何创建线程？创建线程的方法" class="headerlink" title="3.如何创建线程？创建线程的方法"></a>3.如何创建线程？创建线程的方法</h1><h2 id="Java中应用程序和进程的概念"><a href="#Java中应用程序和进程的概念" class="headerlink" title="Java中应用程序和进程的概念"></a>Java中应用程序和进程的概念</h2><p>在Java中，一个应用程序对应一个JVM实例（JVM进程），名字默认为java.exe 或 javaw.exe。</p><p>Java采用单线程编程模型，一般来说，程序中只会创建一个线程，称为主线程main。</p><p><strong>注意：虽然只有一个主线程执行任务，但不代表JVM只有一个线程，JVM实例在创建的时候，同时会创建很多其他的线程（比如垃圾回收器线程）。</strong></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li><strong>继承Thread类</strong>，重写run方法（定义需要执行的任务）；使用自己写的线程类创建线程实例<code>t</code>，调用<code>t.start()</code>方法启动线程。注意：调用<code>t.run()</code>方法，和普通方法调用没有区别，不会创建新的线程。</li><li><strong>实现Runnable接口</strong>，重写run方法。Runnable的含义是“任务”，通过实现Runnable接口，定义一个子任务，然后把子任务交给Thread去执行，还是调用<code>t.start()</code>方法。</li><li>新线程创建的过程不会阻塞主线程的后续的执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        System.out.println(<span class="hljs-string">&quot;主线程ID：&quot;</span>+Thread.currentThread().getId());<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(); <span class="hljs-comment">// 创建一个子任务实例</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable); <span class="hljs-comment">// 把子任务交给Thread去执行</span><br>        thread.start(); <span class="hljs-comment">// 创建新线程，执行子任务</span><br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">()</span> &#123;<br>         <br>    &#125;<br>     <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程ID：&quot;</span>+Thread.currentThread().getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><ul><li>使用ProcessBuilder创建进程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建进程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateProcess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 创建一个ProcessBuilder，传入命令参数</span><br>    <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;ipconfig/all&quot;</span>);<br>    <span class="hljs-comment">// 调用ProcessBuilder.start()方法，返回一个Process对象</span><br>    Process process= pb.start();<br><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(process.getInputStream());<br><br>    <span class="hljs-keyword">while</span> (scanner.hasNextLine())<br>    &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>    scanner.close();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用Runtime类的exec方法创建进程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面的Runtime类的构造方法是私有的，只能在类内实例化对象，并且对象currentRuntime是静态的，就是只有一个，所以Runtime是一个单例的，只能通过getRuntime()方法获取单例对象。</p><p>Runtime类的exec方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Process <span class="hljs-title function_">exec</span><span class="hljs-params">(String[] cmdarray, String[] envp, File dir)</span><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 通过ProcessBuilder的start方法创建ProcessImpl对象。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmdarray)<br>        .environment(envp)<br>        .directory(dir)<br>        .start();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用Runtime创建进程，实际上exec()方法的内部，还是调用ProcessBuilder类的start方法创建进程的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateRuntimeProcess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cmd &quot;</span>+<span class="hljs-string">&quot;/c &quot;</span>+<span class="hljs-string">&quot;ipconfig/all&quot;</span>;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(cmd);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(process.getInputStream());<br><br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine())<br>        &#123;<br>            System.out.println(scanner.nextLine());<br>        &#125;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java内存模型（JMM）总结"><a href="#Java内存模型（JMM）总结" class="headerlink" title="Java内存模型（JMM）总结"></a>Java内存模型（JMM）总结</h1><p>Java内存模型解决的问题：</p><p>1、多线程读同步与可见性问题：</p><p>线程缓存导致的可见性问题：</p><p>解决方法：</p><ul><li>使用volatile关键字，使得在线程中修改的变量立即刷新写回到主内存中，并且每个线程在每次使用volatile变量前都立即从主内存刷新。</li><li>Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li></ul><p>重排序导致的可见性问题：</p><ul><li>volatile关键字：本身包含了禁止指令重排序的语义</li><li>synchronized是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>由于HashMap是线程不安全的，在多线程情况下使用会出现很多问题。</p><p>因此，在多线程情况下如何获得线程安全的HashMap呢？</p><ul><li>Collections.synchronizedMap</li><li>HashTable</li><li>ConcurrentHashMap</li></ul><p>前两种方法由于全局锁的问题，存在很严重的性能问题。</p><p>而ConcurrentHashMap采用分段锁，不是锁整个hash表，而是只锁一部分。</p><h2 id="0-JDK7中的ConcurrentHashMap"><a href="#0-JDK7中的ConcurrentHashMap" class="headerlink" title="0 JDK7中的ConcurrentHashMap"></a>0 JDK7中的ConcurrentHashMap</h2><p>ConcurrentHashMap中有一个Segment数组，Segment可以看做是一个HashMap。</p><p>Segment继承了ReentrantLock，本身就是一个锁。</p><p>每个Segment有一个HashEntry[]数组，数组中的每个HashEntry就是用来存储key-value键值对。</p><p>HashEntry还可以指向下一个HashEntry。</p><p>当一个线程向某个segment中put元素时，segment会将自己上锁，只允许一个线程访问，而对其他的segment的访问没有影响。</p><p>这就是锁分段带来的好处。</p><p>而且segment的put方法是线程安全的，因为在put方法中，先会去尝试获取当前segment的锁，然后才去执行添加元素和扩容等操作。</p><p>扩容操作是针对当前上锁的segment的HashEntry数组进行的，所以是线程安全的。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f29dca9416c8f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="1-JDK8中的ConcurrentHashMap的初始化"><a href="#1-JDK8中的ConcurrentHashMap的初始化" class="headerlink" title="1 JDK8中的ConcurrentHashMap的初始化"></a>1 JDK8中的ConcurrentHashMap的初始化</h2><p>首先执行静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentHashMap&lt;Object, Object&gt; concurrentHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe U;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SIZECTL;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> TRANSFERINDEX;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> BASECOUNT;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> CELLSBUSY;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> CELLVALUE;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ABASE;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ASHIFT;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.Unsafe.getUnsafe();<br>        Class&lt;?&gt; k = ConcurrentHashMap.class;<br>        SIZECTL = U.objectFieldOffset<br>            (k.getDeclaredField(<span class="hljs-string">&quot;sizeCtl&quot;</span>));<br>        TRANSFERINDEX = U.objectFieldOffset<br>            (k.getDeclaredField(<span class="hljs-string">&quot;transferIndex&quot;</span>));<br>        BASECOUNT = U.objectFieldOffset<br>            (k.getDeclaredField(<span class="hljs-string">&quot;baseCount&quot;</span>));<br>        CELLSBUSY = U.objectFieldOffset<br>            (k.getDeclaredField(<span class="hljs-string">&quot;cellsBusy&quot;</span>));<br>        Class&lt;?&gt; ck = CounterCell.class;<br>        CELLVALUE = U.objectFieldOffset<br>            (ck.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        Class&lt;?&gt; ak = Node[].class;<br>        ABASE = U.arrayBaseOffset(ak);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> U.arrayIndexScale(ak);<br>        <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;data type scale not a power of two&quot;</span>);<br>        ASHIFT = <span class="hljs-number">31</span> - Integer.numberOfLeadingZeros(scale);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部的数据结构是Node数组，JDK8不在使用segment 数组的概念，而是Node数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The array of bins. Lazily initialized upon first insertion.</span><br><span class="hljs-comment"> * Size is always a power of two. Accessed directly by iterators.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * hash表，在第一次put数据的时候才初始化，他的大小总是2的倍数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来存储一个键值对</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Key-value entry.  This class is never exported out as a</span><br><span class="hljs-comment"> * user-mutable Map.Entry (i.e., one supporting setValue; see</span><br><span class="hljs-comment"> * MapEntry below), but can be used for read-only traversals used</span><br><span class="hljs-comment"> * in bulk tasks.  Subclasses of Node with a negative hash field</span><br><span class="hljs-comment"> * are special, and contain null keys and values (but are never</span><br><span class="hljs-comment"> * exported).  Otherwise, keys and vals are never null.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f29dc77a0bccf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>线程安全的hash初始化</p><p>hash表 table数组会在第一次执行put方法的实际进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Maps the specified key to the specified value in this table.</span><br><span class="hljs-comment"> * Neither the key nor the value can be null.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="hljs-doctag">@code</span> get&#125; method</span><br><span class="hljs-comment"> * with a key that is equal to the original key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value associated with &#123;<span class="hljs-doctag">@code</span> key&#125;, or</span><br><span class="hljs-comment"> *         &#123;<span class="hljs-doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="hljs-doctag">@code</span> key&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified key or value is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 计算key的hash值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 如果table是空，初始化之</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">// 省略...</span><br>    &#125;<br>    <span class="hljs-comment">// 省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用initTable()方法进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">// #1</span><br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// sizeCtl的默认值是0，所以最先走到这的线程会进入到下面的else if判断中</span><br>        <span class="hljs-comment">// #2</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 首先判断sizeCtl是否小于0，若&lt;0, 当前线程直接变为就绪状态</span><br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// 尝试原子性的将指定对象(this)的内存偏移量为SIZECTL的int变量值从sc更新为-1</span><br>        <span class="hljs-comment">// 也就是将成员变量sizeCtl的值改为-1</span><br>        <span class="hljs-comment">// #3</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//CAS的方式</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 双重检查，原因会在下文分析</span><br>                <span class="hljs-comment">// #4</span><br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY; <span class="hljs-comment">// 默认初始容量为16</span><br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    <span class="hljs-comment">// #5</span><br>                    table = tab = nt; <span class="hljs-comment">// 创建hash表，并赋值给成员变量table</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// #6</span><br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/6/169f29dc7c07e0e7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p><a href="https://juejin.cn/post/6844903813892014087">https://juejin.cn/post/6844903813892014087</a></p><h1 id="Java线程池解析"><a href="#Java线程池解析" class="headerlink" title="Java线程池解析"></a>Java线程池解析</h1><p><a href="https://juejin.cn/post/6844903889678893063">https://juejin.cn/post/6844903889678893063</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记</title>
    <link href="/blog/202205263846569680/"/>
    <url>/blog/202205263846569680/</url>
    
    <content type="html"><![CDATA[<p>SpringMVC源码</p><p>Servlet中的service方法，然后调用doGet或者doPost方法；</p><p>调用processRequest方法—》调用DispatcherServlet的doService方法—》调用DispatcherServlet类中的<strong>doDispatch方法</strong>；</p><p>——》getHandler方法：进行映射，得到对应的HandlerMapping<br>——》getHandlerAdapter方法：遍历多种Adapter对得到的handler进行判断，能处理就处理，得到HandlerAdapter适配器处理器 ha</p><p>调用ha.handle()方法，真正调用handler。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java">在handle()方法中，调用handleInternal() 方法；<br><br>在ReqestMappingHandlerAdapter中：<br>调用ReqestMappingHandlerAdapter 的 handleInternal() 方法<br>判断当前请求是否是支持的；<br>    判断是否要同步session（默认为<span class="hljs-literal">false</span>）<br>    invokeHandlerMethod()方法：对HandlerMethod进行参数的适配处理，并调用目标handler<br>    做很多初始化操作；如设置参数解析器，设置返回值处理器<br>    调用initModel()方法：调用标注了<span class="hljs-meta">@ModelAttribute</span>的方法，做一些初始化操作<br>    对请求参数进行处理，调用invokeAndHandle()方法<br>    调用invokeForRequest()方法：真正调用目标方法，返回Object类型对象<br>    获取目标方法的参数，并解析参数；<br>    调用目标方法，doInvoke(参数)<span class="hljs-comment">// 使用反射调用</span><br>    得到返回值 Object returnValue;<br>遍历所有的ReturnValueHandler，使用支持该类型的handler对当前类型的返回值进行解析;<span class="hljs-comment">// 不同的返回值类型使用不同的返回值解析器来处理</span><br>最终返回mav,ModelAndView;<br>最终handle()方法返回mav, 回到DispatcherServlet类;<br><br>调用拦截器mappedHandler.applyPostHandle()方法;<br>执行processDispatchResult()方法，渲染视图;<br>调用render()方法，解析视图，渲染视图;<br>resolveViewName()方法解析视图名;<span class="hljs-comment">// 为最初的视图名称拼接上了前缀和后缀, 设置了contentType</span><br>遍历viewResolvers视图解析器，一个一个地去解析视图，解析成功返回view;<br>调用view.render()方法;<br>调用renderMergedOutputModel()方法;<br>调用exposeModelAsRequestAttributes(model, request)方法，将model设置到request的attribute中; <span class="hljs-comment">// 将model中的name和value解析出来，并设置到request.setAttribute()中。</span><br>设置国际化资源;<br>防止死循环请求;<br>通过request拿到RequestDispatcher，调用getRequestDispatcher(request, dispatcherPath);<span class="hljs-comment">// 通过一个请求和一个地址，获得RequestDispatcher rd</span><br>rd.forward(request, response); <span class="hljs-comment">// RequestDispatcher.forward直接转发</span><br><br><br></code></pre></td></tr></table></figure><p>——》HandlerAdapter适配器处理器 解析参数、执行方法，解析返回值，并返回ModelAndView，</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/blog/202205202545824373/"/>
    <url>/blog/202205202545824373/</url>
    
    <content type="html"><![CDATA[<p>Spring源码1-3</p><p>SpringMVC源码4</p><h1 id="第1节"><a href="#第1节" class="headerlink" title="第1节"></a>第1节</h1><h2 id="Spring概念和使用"><a href="#Spring概念和使用" class="headerlink" title="Spring概念和使用"></a>Spring概念和使用</h2><p>注解方式管理Bean：</p><p><strong>1、注解方式 创建对象IOC</strong></p><p>导入依赖 aop</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>    放在类上,用于标记,告诉spring当前类需要由容器实例化bean并放入容器中<br>该注解有三个子注解<br><span class="hljs-meta">@Controller</span>   用于实例化controller层bean<br><span class="hljs-meta">@Service</span>        用于实例化service层bean<br><span class="hljs-meta">@Repository</span>  用于实例化持久层bean<br>当不确定是哪一层,就用Component<br></code></pre></td></tr></table></figure><p>这几个注解互相混用其实也可以,但是不推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一步:在applicationContext.xml中配置开启注解扫描</span><br>    &lt;!--添加注解扫描,扫描指定的包,将包中的所有有注解的类实例化<br>    base-<span class="hljs-keyword">package</span> 后面放要扫描的包<br>    如果有多个包需要扫描,可以使用逗号隔开  com.msb.bean,com.msb.service<br>    或者可以写上一层包路径  com.msb<br>    可以通过注解指定bean的id <span class="hljs-meta">@Component(&quot;user1&quot;)</span><br>    如果不指定,则id默认是 类名首字母小写<br>    --&gt;<br>&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.zzflybird.bean&quot;</span>&gt;&lt;/context:component-scan&gt;<br><br><span class="hljs-comment">// 第二步:在类上添加注解,让spring容器给我们创建bean实例并存储于容器中</span><br><span class="hljs-meta">@Component(value = &quot;user1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 单元测试</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userTest</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring.xml&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user1&quot;</span>);<br>    System.out.println(user1);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、注解方式 依赖注入DI</strong></p><p>@Autowired   根据属性数据类型自动装配<br>@Qualifier      根据属性名称注入依赖<br>@Resources   可以根据类型,也可以根据名称注入<br>@Value           注入普通数据类型(8+String)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @Autowired</span><br><span class="hljs-comment">* 根据类型到容器中去寻找对应的对象,找到后给当前属性赋值</span><br><span class="hljs-comment">* 不需要依赖 set方法</span><br><span class="hljs-comment">* 属性类型可以是接口,会自动匹配对应的实现类对象</span><br><span class="hljs-comment">* @Autowired配合 @Qualifier,可以通过名称指定注入的对象</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @Resource 如果不配置name 那么就是根据类型注入</span><br><span class="hljs-comment">* @Resource(name=&quot;userDaoImplB&quot;) 配置name,就是根据名称注入</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @Resource  是JDK中javax包的注解</span><br><span class="hljs-comment">* @Autowired 和 @Qualifier 是spring中的注解</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* @Value 可以个普通属性赋值</span><br><span class="hljs-comment">* @Value 可以使用$&#123;&#125;这种表达式获取系统的变量值</span><br><span class="hljs-comment">*        或者是.properties属性配置文件中的值</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* */</span><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-comment">//@Qualifier(&quot;userDaoImplA&quot;)</span><br><span class="hljs-comment">//@Qualifier(&quot;userDaoImplB&quot;)</span><br><span class="hljs-comment">//private UserDao userDao ;</span><br><span class="hljs-meta">@Resource(name=&quot;userDaoImplB&quot;)</span><br><span class="hljs-keyword">private</span> UserDao userDao ;<br><span class="hljs-meta">@Value(&quot;$&#123;username&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String sname;<br><span class="hljs-meta">@Value(&quot;boy&quot;)</span><br><span class="hljs-keyword">private</span> String sgender;<br><span class="hljs-meta">@Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="hljs-keyword">private</span> Integer sage;<br><br></code></pre></td></tr></table></figure><p><strong>3、完全使用注解</strong></p><p><strong>创建配置类</strong>，替代xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.zzflybird&quot;)</span> <span class="hljs-comment">// 配置扫描包</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:aaa.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfigTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">springConfigTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userServiceImpl</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userServiceImpl&quot;</span>, UserServiceImpl.class);<br>        userServiceImpl.add();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JDK Proxy动态代理：面向接口</strong></p><ul><li>必须有接口和实现类 </li><li>只能增强接口中定义的方法</li><li>只能读取接口中方法的上注解</li></ul><blockquote><ol><li>在不修改原有代码的 或者没有办法修改原有代码的情况下  增强对象功能  使用代理对象 代替原来的对象去完成功能<br>进而达到拓展功能的目的</li><li>JDK Proxy 动态代理面向接口的动态代理  一定要有接口和实现类的存在 代理对象增强的是实现类 在实现接口的方法重写的方法</li></ol><ul><li>生成的代理对象只能转换成 接口的不能转换成 被代理类</li><li>代理对象只能增强接口中定义的方法  实现类中其他和接口无关的方法是无法增强的</li><li>代理对象只能读取到接口中方法上的注解 不能读取到实现类方法上的注解</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// Proxy  动态代理 JDK动态代理         面向接口</span><br><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dinner</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String foodName)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 被代理类，实现接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Dinner</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String foodName)</span> &#123;<br>        System.out.println(name+<span class="hljs-string">&quot;:吃&quot;</span>+foodName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;:喝&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PorxyTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">proxyTest</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">Dinner</span> <span class="hljs-variable">dinner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//被代理的对象的类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> dinner.getClass().getClassLoader();<br>        <span class="hljs-comment">//被代理对象所实现的所有接口</span><br>        Class&lt;?&gt;[] interfaces = dinner.getClass().getInterfaces();<br><br>        <span class="hljs-comment">//执行处理器对象,专门用于定义增强的规则</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, // 代理对象</span><br><span class="hljs-params">                                 Method method, // 被代理的方法</span><br><span class="hljs-params">                                 Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;eat&quot;</span>))<br>                &#123;<br>                    System.out.println(<span class="hljs-string">&quot;在被代理方法 eat() 前 do something&quot;</span>);<br>                    <span class="hljs-comment">// 调用被代理对象的方法</span><br>                    res = method.invoke(dinner, args);<br>                &#125; <span class="hljs-keyword">else</span><br>                &#123;<br>                    res = method.invoke(dinner, args);<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//通过Porxy动态代理获得一个代理对象,在代理对象中,对某个方法进行增强</span><br>        <span class="hljs-comment">// 代理对象只能转换成接口，不能转换成 被代理类</span><br>        <span class="hljs-type">Dinner</span> <span class="hljs-variable">dinnerProxy</span> <span class="hljs-operator">=</span> (Dinner) Proxy.newProxyInstance(loader, interfaces, invocationHandler);<br>        dinnerProxy.drink();<br>        dinnerProxy.eat(<span class="hljs-string">&quot;冒菜&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>CGLIB动态代理： 面向父类</strong></p><ol><li>面向父类，和接口没有直接关系</li><li>不仅可增强接口中定义的方法，还可以增强一个类其他的方法</li><li>可以读取父类中方法上的所有注解</li></ol><p><img src="/blog/.io//Spring%E7%AC%94%E8%AE%B0/image-20220521160949458.png" alt="image-20220521160949458"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>AOP切面编程一般可以帮助我们在不修改现有代码的情况下,对程序的功能进行拓展,往往用于实现 日志处理,权限控制,性能检测,事务控制等<br>AOP实现的原理就是动态代理，在有接口的情况下,使用JDK动态代理,在没有接口的情况下使用cglib动态代理</strong></p><p><strong>AOP中的术语辨析</strong></p><p>1 连接点 Joint point:<br>类里面那些可以被增强的方法,这些方法称之为连接点<br>表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point</p><p>2 <strong>切入点 Pointcut:</strong><br><strong>实际被增强的方法,称之为切入点</strong>，”execution(* com.zzflybird.dao.<em>.add</em>(..))”<br>表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方</p><p>3 通知 Advice:<br>实际增强的逻辑部分称为通知 (增加的功能)<br>Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。<br>通知类型: 1 前置通知 2 后置通知 3 环绕通知 4 异常通知 5 最终通知</p><p>4 目标对象 Target：被增强功能的对象(被代理的对象)<br>织入 Advice 的目标对象</p><p>5 切面Aspect： 表现为功能相关的一些advice方法放在一起声明成的一个Java类<br>Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</p><p>6 织入 Weaving：<br>创建代理对象并实现功能增强的声明并运行过程<br>将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</p><p><strong>AOP的实现：基于注解（熟练）</strong></p><h2 id="Spring原理笔记"><a href="#Spring原理笔记" class="headerlink" title="Spring原理笔记"></a>Spring原理笔记</h2><h3 id="Spring-Bean的创建生命周期："><a href="#Spring-Bean的创建生命周期：" class="headerlink" title="Spring Bean的创建生命周期："></a><strong>Spring Bean的创建生命周期</strong>：</h3><p>根据一个类最终得到一个Bean对象，中间经过的步骤。</p><p>UserService.class—&gt;无参构造方法（推断构造方法）—》普通对象—》依赖注入（属性赋值）—》初始化前（@PostConstruct）—–》初始化（InitializingBean）—》初始化后（AOP）—》代理对象—-》Bean</p><p>推断构造方法：使用哪个构造方法，构造方法的参数去哪里拿</p><p>Bean的销毁的生命周期</p><p>推断构造方法：</p><p>如果一个类中只有一个有参构造方法，spring就用这个。</p><p>如果一个类中有多个有参构造方法，spring不知道用哪一个，就会去找无参构造方法，如果找不到无参构造方法，就会报错。</p><p>有参构造方法的参数是一个类A的对象a，spring会先从spring容器中通过类名A找对应类型的Bean，如果找到了1个bean，就用这个bean给构造方法；如果使用类名A找到多个bean，就再用参数名a找与其名称相同的bean，把名称相同的bean给构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EmpDao empDao;<br><br><span class="hljs-comment">//    public UserDaoImpl() &#123;</span><br><span class="hljs-comment">//    &#125;</span><br><br><span class="hljs-comment">//    @Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDaoImpl</span><span class="hljs-params">(EmpDao empDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.empDao = empDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 没有默认构造方法，对于两个有参构造方法，想让spring用哪一个，就加上@Autowired注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDaoImpl</span><span class="hljs-params">(EmpDao empDao, EmpDao empDao1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.empDao = empDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><p>UserService等价于UserDao，OrderService等价于EmpDao</p><p>Spring生成Bean的过程：UserService.class—&gt;无参构造方法（推断构造方法）—》<strong>普通对象</strong>—》<strong>依赖注入（属性赋值）</strong>—》初始化前（@PostConstruct）—–》初始化（InitializingBean）—》初始化后（AOP）—》代理对象—-》Bean</p><p>UserServiceProxy类—-&gt;代理对象—-&gt;代理对象.target &#x3D;  <strong>普通对象</strong></p><p>代理对象.test()方法—&gt;进入到代理类的test方法中，执行target.test()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserService</span><br>&#123;<br>    UserService target;<span class="hljs-comment">// 普通对象，进行过依赖注入的，其属性是有值的</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 先执行@Before修饰的方法，执行切面逻辑</span><br>        target.test();<span class="hljs-comment">// 普通对象.test()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而代理对象里面的orderService (empDao)对象是没有赋值的，是null的。</p><p><img src="/blog/.io//Spring%E7%AC%94%E8%AE%B0/image-20220521215633666.png" alt="image-20220521215633666"></p><p>普通对象是进行了依赖注入的，它的属性是有值的。</p><p><img src="/blog/.io//Spring%E7%AC%94%E8%AE%B0/image-20220521215812470.png" alt="image-20220521215812470"></p><p>Spring生成Bean的过程：UserService.class—&gt;无参构造方法（推断构造方法）—》<strong>普通对象</strong>—》<strong>依赖注入（属性赋值）</strong>—》初始化前（@PostConstruct）—–》初始化（InitializingBean）—》初始化后（AOP）—》代理对象—-》Bean</p><p>在<strong>初始化后（AOP）</strong>这一步，判断UserService要不要进行AOP，根据UserService中的方法是否被切了来判断。那么如何判断UserService中的有没有方法被切了呢？</p><p>1、找出所有的切面Bean</p><p>2、遍历所有的切面Bean</p><p>3、对于每一个切面Bean，遍历其所有方法</p><p>4、如果 某切面Bean中方法beforeMethod()的<strong>注解表达式中的某个方法test()</strong> &#x3D;&#x3D; <strong>UserService中的某个方法test()<strong>，就把</strong>方法beforeMethod()<strong>放入map中缓存下来。存下来的方法</strong>beforeMethod()<strong>后面在</strong>test()方法</strong>前执行的时候直接去map中找方法来执行。map&lt;UserService.class, method list&gt;</p><h3 id="Spring-事务原理"><a href="#Spring-事务原理" class="headerlink" title="Spring 事务原理"></a>Spring 事务原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 想要使用自动注解打开事务，结果发现没有注解，事务需要配置额外的包</span><br><br></code></pre></td></tr></table></figure><p>2小时打卡，AOP原理，Spring中的Bean（代理对象）与普通对象的区别？</p><p>Spring中的Bean就是一个代理对象。</p><p>加不加注解@Configuration对事务的作用：</p><p>两个不同的dataSource对象，一个是JdbcTemplate中自己的，另一个是Spring事务管理器创建的dataSource对象，创建连接conn，并关闭conn的自动提交。</p><p>JdbcTemplate和Spring事务管理器中的dataSource要是同一个dataSource，事务才会有效。</p><p>加了事务注解的方法中，调用该方法的对象是普通对象还是代理对象，如果是代理对象那么事务注解就有用。</p><h1 id="第2节"><a href="#第2节" class="headerlink" title="第2节"></a>第2节</h1><h2 id="手写Spring"><a href="#手写Spring" class="headerlink" title="手写Spring"></a>手写Spring</h2><p>Spring生成Bean的过程：</p><p>UserService.class—&gt;无参构造方法（推断构造方法）—》<strong>普通对象</strong>—》<strong>依赖注入（属性赋值）</strong>—》<strong>初始化前（@PostConstruct）</strong>—–》初始化（InitializingBean）—》<strong>初始化后（AOP）</strong>—》代理对象—-》Bean</p><p>创建ConfigAppcontext类</p><p>创建Config配置类</p><p>创建@配置注解</p><p>实现Appcontext的构造方法</p><p>扫描方法</p><p>实例化对象</p><p>BeanDefination</p><p>beanDefinationMap</p><p>singletonObjectsMap</p><p>实现依赖注入—-》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 进行依赖注入, 得到Bean对象的类中的所有属性，判断是否有Autowired注解</span><br>Field[] declaredFields = clazz.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>    System.out.println(field);<br><br>    <span class="hljs-keyword">if</span> (field.isAnnotationPresent(Autowired.class)) &#123;<br><br>        <span class="hljs-comment">// 在访问 属性 域时，Java进行了访问检查，发现该域是private修饰的，不能直接访问，因此抛出异常。</span><br>        <span class="hljs-comment">// 解决方法: 关闭安全检查, 使可以访问私有属性, 反射的对象在使用时应该取消 Java 语言访问检查</span><br>        field.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 先根据类型去找Bean，如果找到多个Bean，在根据名字去找</span><br>        <span class="hljs-comment">//                    System.out.println(field.getType());</span><br><br>        <span class="hljs-comment">// 根据field.getName()名字去找Bean</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">fieldBean</span> <span class="hljs-operator">=</span> getBean(field.getName());<br>        <span class="hljs-comment">// 为 instance 对象的 field 属性，设置值 = getBean(field.getName())</span><br>        field.set(instance, fieldBean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行初始化—-》UserService类 实现 InitializingBean接口来进行初始化，先自己定义InitializingBean接口，在UserService类中重写InitializingBean接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层源码实现：</span><br><span class="hljs-comment">// 在依赖注入后，进行初始化: 判断 instance 是否实现了 InitializingBean 接口</span><br><span class="hljs-keyword">if</span> (instance <span class="hljs-keyword">instanceof</span> InitializingBean)<br>&#123;<br>    ((InitializingBean) instance).afterPropertiesSet(); <span class="hljs-comment">// 调用初始化方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BeanPostProcessor(最重要的东西)，用于实现 初始化前，初始化后</p><p>实现 初始化前，初始化后 的功能——-》创建BeanPostProcessor接口，然后定义2个抽象方法：</p><ol><li><code>postProcessBeforeInitialization()</code> 初始化前</li><li><code>postProcessAfterInitialization()</code> 初始化后</li></ol><p>用自己创建的ZzflybirdBeanPostProcessor类实现BeanPostProcessor接口，并标注注解，设置为Bean，使得spring可以扫描到。</p><p>在spring扫描的过程中，将 实现了BeanPostProcessor接口的类 进行实例化，得到对象，并保存到beanPostProcessorList中。</p><p>方便在后面createBean()中，</p><p>在 【依赖注入】–》【初始化前】——–》【初始化】———–》【初始化后】中的初始化前和初始化后中调用beanPostProcessorList中的对象的两个重写的方法。</p><p>每一个Bean都会调用postProcessBeforeInitialization()和postProcessAfterInitialization()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化前</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean 传入的 bean 实例， 可以对其进行操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName 传入的beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;初始化前&quot;</span> + beanName);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化后</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean 传入的 bean 实例， 可以对其进行操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName 传入的beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;初始化后&quot;</span> + beanName);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring中AOP的底层就是通过BeanPostProcessor接口的两个方法实现的，因为这两个方法传入bean，然后可以在bean调用方法前，进行一些操作，这就是AOP。</p><p>基于 BeanPostProcessor 这个机制，传入bean，再传出bean，可以对bean做很多事情。</p><p>Aware回调功能：</p><p>在bean中获取beanName；</p><p>创建BeanNameAware接口，setBeanName()方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于 让一个bean 知道自己的名字，设置 beanName</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanNameAware</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String beanName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>让一个Bean类实现这个BeanNameAware接口，重写setBeanName方法，Spring底层会自动调用setBeanName方法，为属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String beanName;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beanName = beanName;<br>&#125;<br></code></pre></td></tr></table></figure><p>Aware回调功能是在【依赖注入】后，【初始化前】之前执行的。</p><p>如何实现：</p><ol><li>判断bean对象是否实现了BeanNameAware接口，即 <code>bean instanceof BeanNameAware</code></li><li>然后将bean强制类型转换为BeanNameAware</li><li>再调用<code>bean.setBeanName(beanName)</code>方法即可，就设置了beanName。</li><li>注意：<code>setBeanName(beanName)</code>方法的内容是要自己写的哦。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Aware回调：设置beanName</span><br><span class="hljs-keyword">if</span> (instance <span class="hljs-keyword">instanceof</span> BeanNameAware)<br>&#123;<br>    <span class="hljs-comment">// 设置beanName</span><br>    ((BeanNameAware) instance).setBeanName(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：过一遍ZzflybirdApplicationContext类的初始化过程，和getBean的过程；</p><p><strong>着重理解BeanPostProcessor 机制的实现原理。</strong></p><h1 id="第3节"><a href="#第3节" class="headerlink" title="第3节"></a>第3节</h1><p>4h48m, 03-Spring之底层架构核心概念解析</p><p>课程内容<br>1、BeanDefinition以及 BeanDefinitionReader<br>2、BeanFactory与ApplicationContext<br>3、Spring中的类型转化组件<br>4、Spring中的比较器OrderComparator<br>5、BeanPostProcessor与 BeanFactoryPostProcessor<br>6、Spring中特殊的Bean之FactoryBean<br>7、ExcludeFilter和IncludeFilter<br>8、Spring中类元数据读取 器之MetadataReader</p><p>创建BeanDefinition的方法有两种：</p><p>声明式定义Bean；声明式有：@Component、@Bean、xml声明Bean。spring底层会为这些Bean自动创建BeanDefinition对象，然后去读取Bean的各种信息和属性放入BeanDefinition对象中。</p><p>编程式定义Bean；</p><p>1、Spring的底层要使用编程式的方法创建BeanDefinition对象。如下图方框中的代码，在源码中很多使用这种方式创建BeanDefinition的。</p><p><img src="/blog/.io//Spring%E7%AC%94%E8%AE%B0/image-20220527224307025.png" alt="image-20220527224307025"></p><p>注册Bean的：</p><p>AnotatedBeanDefinitionReader，传Bean.class</p><p>XmlBeanDefinitionReader，传sping.xml</p><p>扫描器：</p><p>ClassPathBeanDefinitionScanner，传一个string扫描路径。</p><p>总结：</p><p>AnotatedBeanDefinitionReader是用来注册BeanDefinition的，得到的是<strong>AnotatedGenricBeanDefinition</strong></p><p>ClassPathBeanDefinitionScanner是用来扫描BeanDefinition的，得到的是<strong>ScanedGenericBeanDefinition</strong></p><p>这两个BeanDefinition都是一个抽象类<strong>AbstractGenericBeanDefinition</strong>的子类。</p><p>所以BeanDefinition整体看来是有一个，但是在底层是细分为2种不同的BeanDefinition的。</p><h3 id="BeanFactory-amp-AppcationContext"><a href="#BeanFactory-amp-AppcationContext" class="headerlink" title="BeanFactory &amp; AppcationContext"></a>BeanFactory &amp; AppcationContext</h3><p>Sping中，BeanFactory是一个接口，AppcationContext也是一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> <br></code></pre></td></tr></table></figure><p>AppcationContext接口是继承了BeanFactory接口的，</p><p>什么意思呢？</p><p>AppcationContext就是一个BeanFactory，BeanFactory接口有的方法它都有。</p><p>例如: context.getBean()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver<br></code></pre></td></tr></table></figure><p><code>ApplicationContext</code>除了继承了BeanFactory接口，还继承了其他的接口，这些其他的接口是BeanFactory所没有的功能；</p><p>EnvironmentCapable：获取环境变量的功能</p><p>MessageSource：进行国际化的功能</p><p>ApplicationEventPublisher：事件发布器</p><p>ResourcePatternResolver：拥有直接解析某些资源的功能</p><p>DefaultListableBeanFactory是BeanFactory一个非常强大的实现类。</p><p>BeanFactory可以用来注册beanDefinition对象。</p><p>ApplicationContext的getBean()方法的底层是通过创建一个DefaultListableBeanFactory作为beanFactory来调用beanFactory的getBean()方法的。</p><p>DefaultListableBeanFactory涉及到的接口：</p><p>HierarchicalBeanFactory：这个接口可以获得子BeanFactory的父BeanFactory</p><p>ListableBeanFactory：Listable展示Bean的名字、数量、统计信息，得到某一个类型的Bean信息</p><p>事件发布器；</p><p>事件监听器；</p><p>类型转换器：</p><p>ComponentScan扫描可以排除，也可以包含；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git报错：fatal: unable to access &#39;https://github.com/xxxxxx/xxxxxx.github.io.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</title>
    <link href="/blog/20220517433679196/"/>
    <url>/blog/20220517433679196/</url>
    
    <content type="html"><![CDATA[<p>在使用<code>hexo g -d</code>推送博客时，报错：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">fatal: unable to access <span class="hljs-string">&#x27;https://github.com/xxxxxx/xxxxxx.github.io.git/&#x27;</span>: OpenSSL SSL_read: Connection was reset, errno <span class="hljs-number">10054</span><br></code></pre></td></tr></table></figure><p>原因：</p><blockquote><p><strong>一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以才报错</strong></p></blockquote><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.sslVerify <span class="hljs-string">&quot;false&quot;</span><br><span class="hljs-comment"># 再次执行</span><br>hexo g -d<br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/weixin_45963617/article/details/123132273">https://blog.csdn.net/weixin_45963617/article/details/123132273</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识蒸馏笔记</title>
    <link href="/blog/202205151223121085/"/>
    <url>/blog/202205151223121085/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo g -d 报错</title>
    <link href="/blog/202205132599919389/"/>
    <url>/blog/202205132599919389/</url>
    
    <content type="html"><![CDATA[<p>具体报错信息：</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/zzflybird/zzflybird.github.io.git/&#39;">https://github.com/zzflybird/zzflybird.github.io.git/&#39;</a>: Failed to connect to github.com port 443 after 21225 ms: Timed out</p></blockquote><p>解决方法：<br>（1）取消代理(clash)</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>（2）设置代理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//127.0.0.1:7890 </span><br>git config <span class="hljs-attr">--global</span> https<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//127.0.0.1:7890</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>github报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/blog/202205132053794650/"/>
    <url>/blog/202205132053794650/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/blog/.io//202205132053794650/test.png" class title="图片引用方法一"><p><img src="/blog/.io//test.png" alt="图片引用方法二"></p><p><img src="/blog/images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zzflybird</title>
  
  <subtitle>我自踏梯而行</subtitle>
  <link href="https://zzflybird.github.io/atom.xml" rel="self"/>
  
  <link href="https://zzflybird.github.io/"/>
  <updated>2023-12-13T14:33:14.677Z</updated>
  <id>https://zzflybird.github.io/</id>
  
  <author>
    <name>zzflybird</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于netstat命令</title>
    <link href="https://zzflybird.github.io/20231213285109806/"/>
    <id>https://zzflybird.github.io/20231213285109806/</id>
    <published>2023-12-13T14:00:51.000Z</published>
    <updated>2023-12-13T14:33:14.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作中，在CentOS系统中会使用<code>netstat -antp</code>这个命令查看网络情况和端口监听情况，但是也是看同事输入这个命令后，看了一眼，就知道了问题所在，我也想能到这个程度，不过可能需要10年的努力和沉淀，慢慢来。</p><h1 id="netstat命令参数"><a href="#netstat命令参数" class="headerlink" title="netstat命令参数"></a>netstat命令参数</h1><p>常用的命令是 <code>netstat -antp | grep 端口号</code> ，配合管道命令可以查询目标端口是否开放。</p><ul><li>其中，a表示显示所有连接和监听的端口，a是all的首字母。</li><li>n表示显示IP，n是numeric的首字母，以数字形式显示地址和端口号。不带n时，会进行DNS轮询，需要等待一段时间，带n可以加速操作。</li><li>t表示显示TCP端口，t是TCP的首字母。</li><li>p表示显示进程标识符和程序名称，每一个套接字和端口都属于一个程序，p是program的首字母。</li><li>l表示仅显示监听套接字的，l是listening的首字母。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在工作中，在CentOS系统中会使用&lt;code&gt;netstat -antp&lt;/code&gt;这个命令查看网络情况和端口监听情况，但是也是看同事输</summary>
      
    
    
    
    <category term="Linux" scheme="https://zzflybird.github.io/categories/Linux/"/>
    
    
    <category term="Linux命令" scheme="https://zzflybird.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>周记1</title>
    <link href="https://zzflybird.github.io/20231122800059456/"/>
    <id>https://zzflybird.github.io/20231122800059456/</id>
    <published>2023-11-22T14:25:23.000Z</published>
    <updated>2023-11-22T14:26:25.162Z</updated>
    
    <content type="html"><![CDATA[<p>上个周末安排的很满，现在回想起来已经忘记当时做了什么了，但是应该都是大差不差的样子：取平台上买的菜、去菜市场买肉、洗衣服、打扫卫生、理发这些。<br>可能是周末没有休息好，周一上班非非非常累。在想着赶快过去吧。幸好周一不用加班。<br>周一晚上早早入睡，希望能够恢复以往的精力。</p><p>周二加班，晚上9点回来，只想看视频娱乐，完全提不起输入或输出的兴趣。晚11点半就洗漱休息了。</p><hr><p>这两天一直在看郑州的亮亮丽君夫妇的消息，得知他们被打后，决定离开郑州，也是，上有老，下有小，不为自己考虑，也要为家里人考虑。</p><hr><p>看到一篇公众号文章里提到</p><blockquote><p>《应得的权利》一书中说，情绪劳动是“女性为了密切关注生活中的小事所做的免费而无形的工作，这些工作加在一起就成为生活中的大事：情绪劳动是把家庭甚至社会凝聚在一起的黏合剂。情绪劳动包括很多——（出行前）密切关注各种信息、提前计划很多事情。这些工作经常都落在女性身上：知道什么东西在哪里、谁需要什么、杂货清单、家庭预算、家庭活动安排等——更不用说，还要收拾没完没了的包，小到尿布包，大到行李箱。”</p></blockquote><p>我一直有列事项清单的习惯，什么时候需要做什么事情，会设置提醒事项，生怕自己忘记。这个是读研的时候的习惯，因为当时一边上课，一边又要自学科研相关的。<br>现在工作了，自己在外独立生活，吃喝拉撒，什么事情都要操心。今天晚上回来就忘记去取快递了，很多这种明明记得要做，但是事情太多，就忘记了。<br>此外，做饭也需要消耗很多精力，准备食材，平台买菜，菜市场买肉。看b站的一个up，每天早上7点起来准备早饭和午饭，晚上也回家做饭。我是早饭看是否有时间做，有时间就做个手抓饼，没时间就吃个面包，或者到公司楼下买个包子，因为晚上休息的晚，早上7点30左右起。如果晚上要回来做饭，就要把肉先给放到冰箱保险中解冻，就这解冻的步骤，我忘记了好多次，晚上回来只能把肉拿出来当场滑动再切一下，一套晚饭操作下来，刷着视频流吃完饭基本上到了8点左右。</p><p>我还想自我提高一下，看下学习视频，或者写一些文字性技术性的输出，大多是流水账，或者是对于某件事的感触。</p><p>不是还有那句话吗，时间就像海绵里的水，只要愿意挤，总还是有的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上个周末安排的很满，现在回想起来已经忘记当时做了什么了，但是应该都是大差不差的样子：取平台上买的菜、去菜市场买肉、洗衣服、打扫卫生、理发这些。&lt;br&gt;可能是周末没有休息好，周一上班非非非常累。在想着赶快过去吧。幸好周一不用加班。&lt;br&gt;周一晚上早早入睡，希望能够恢复以往的精</summary>
      
    
    
    
    <category term="周记" scheme="https://zzflybird.github.io/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://zzflybird.github.io/tags/%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>netty-1</title>
    <link href="https://zzflybird.github.io/202304093691450081/"/>
    <id>https://zzflybird.github.io/202304093691450081/</id>
    <published>2023-04-09T09:04:50.000Z</published>
    <updated>2023-04-21T02:24:02.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><p>要见森林，不要局限于树木。</p><p>netty</p><p>把微服务中的服务的功能，使用中间件来解决。</p><p>将依赖代码注解变为 服务网格化编程，ServerMash。</p><p>把有侵入性的服务从代码中转嫁到中间件中。</p><p>netty 是解决通信问题的，效率要高。</p><p>还是要用 Spring Cloud 的，要用 RPC 的。</p><p>Dubbo RQ </p><h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><ul><li>Netty and 源码</li><li>RPC编程 grpc</li><li>Dubbo and 源码</li><li>MQ and rocketmq源码：(kafka rocketmq) 源码中rocketmq的使用</li><li>分布式算法：强一致性算法；对分布式领域的有更深入的理解；(CAP, 存储都是CP, AP)</li><li>SpringCloud and 源码</li></ul><blockquote><p>21min</p></blockquote><p>目的：认识到软件的思想，提高设计能力，了解目前系统架构的发展演变，与底层实现。</p><p>架构师和业务开发是两个工作。</p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Netty-是什么"><a href="#Netty-是什么" class="headerlink" title="Netty 是什么"></a>Netty 是什么</h2><p>Netty 是一个异步事件驱动的网络应用框架，解决的是服务器和客户端之间的通信问题。它是一个<strong>NIO客户服务器框架</strong>。<br>它是对Java中NIO的封装。</p><p>常用netty4版本。</p><h2 id="为什么需要-Netty-amp-amp-Netty能做什么"><a href="#为什么需要-Netty-amp-amp-Netty能做什么" class="headerlink" title="为什么需要 Netty &amp;&amp; Netty能做什么"></a>为什么需要 Netty &amp;&amp; Netty能做什么</h2><ul><li>它是行业内网络通信编程的标准，用于其他中间件的底层。</li><li>用于游戏行业；</li><li>框架的通信底层，解决进程间通信问题；</li><li>是分布式系统，通信的核心；</li></ul><h2 id="NIO是什么"><a href="#NIO是什么" class="headerlink" title="NIO是什么"></a>NIO是什么</h2><p>前面在Netty的介绍中提到，它是一个NIO客户服务器框架，那NIO是什么呢？</p><ul><li>NIO的全称是 None Blocking IO <strong>非阻塞IO</strong>，在JDK1.4中引入，用于解决阻塞的问题。</li><li>非阻塞的优点：能够在网络通信过程中，解决通信阻塞的问题，更加合理利用系统资源，提高系统并发效率。支持高并发的系统访问。</li></ul><h2 id="传统网络通信的开发方式（socket）和问题"><a href="#传统网络通信的开发方式（socket）和问题" class="headerlink" title="传统网络通信的开发方式（socket）和问题"></a>传统网络通信的开发方式（socket）和问题</h2><p>对于一个客户端的socket连接，会新创建一个线程。</p><h3 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h3><ol><li>线程创建资源开销大；</li><li>创建线程会占用内存，不能无限制创建；</li><li>CPU使用率高；</li></ol><h3 id="线程池的网络通信编程（池化）和问题"><a href="#线程池的网络通信编程（池化）和问题" class="headerlink" title="线程池的网络通信编程（池化）和问题"></a>线程池的网络通信编程（池化）和问题</h3><p>线程池的参数：</p><ol><li>core pool size：核心线程数，使用OS的cpu核数作为参数，但是JDK8以后的可以在虚拟机参数中指定核心线程数，因为Java应用往往跑在docker上，不知道机器的真实核数是多少了。</li><li>最大线程数量：</li></ol><p>优化方案：</p><ol><li>使用线程池预先定义好线程的数量，解决了线程不断创建的开销；</li><li></li></ol><h2 id="NIO如何解决阻塞问题-amp-amp-原理"><a href="#NIO如何解决阻塞问题-amp-amp-原理" class="headerlink" title="NIO如何解决阻塞问题 &amp;&amp; 原理"></a>NIO如何解决阻塞问题 &amp;&amp; 原理</h2><h2 id="Netty-的原理"><a href="#Netty-的原理" class="headerlink" title="Netty 的原理"></a>Netty 的原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式架构&quot;&gt;&lt;a href=&quot;#分布式架构&quot; class=&quot;headerlink&quot; title=&quot;分布式架构&quot;&gt;&lt;/a&gt;分布式架构&lt;/h1&gt;&lt;p&gt;要见森林，不要局限于树木。&lt;/p&gt;
&lt;p&gt;netty&lt;/p&gt;
&lt;p&gt;把微服务中的服务的功能，使用中间件来解决。&lt;/p</summary>
      
    
    
    
    <category term="Netty" scheme="https://zzflybird.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://zzflybird.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-31. 下一个排列</title>
    <link href="https://zzflybird.github.io/202208313370095749/"/>
    <id>https://zzflybird.github.io/202208313370095749/</id>
    <published>2022-08-31T14:56:58.000Z</published>
    <updated>2022-08-31T15:00:26.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-31-下一个排列"><a href="#leetcode-31-下一个排列" class="headerlink" title="leetcode-31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">leetcode-31. 下一个排列</a></h2><ol><li>从后向前找，找非降序排列的第一个位置, nums[k-1] &lt; nums[k]</li><li>从后向前找，找</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[k<span class="hljs-number">-1</span>] &lt; nums[k]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> k--;<br>        &#125;<br>        <span class="hljs-comment">// 如果序列是 纯递减序列，就翻转一下</span><br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// nums[k-1] 和 k 是第一个 升序的，要在 k 后面找到比 nums[k-1] 大的最小的数</span><br>            <span class="hljs-type">int</span> t = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 从后向前找 t</span><br>            <span class="hljs-keyword">while</span> (t &gt; <span class="hljs-number">0</span> &amp;&amp; nums[t] &lt;= nums[k - <span class="hljs-number">1</span>]) t--;<br><br>            <span class="hljs-built_in">swap</span>(nums[k<span class="hljs-number">-1</span>], nums[t]); <span class="hljs-comment">// 把2个数交换</span><br>            <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转 nums[k] 后面的所有数，把降序变为升序</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;leetcode-31-下一个排列&quot;&gt;&lt;a href=&quot;#leetcode-31-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;leetcode-31. 下一个排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/probl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-22. 括号生成</title>
    <link href="https://zzflybird.github.io/202208301142076060/"/>
    <id>https://zzflybird.github.io/202208301142076060/</id>
    <published>2022-08-30T14:30:11.000Z</published>
    <updated>2022-08-31T14:59:06.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-22-括号生成"><a href="#leetcode-22-括号生成" class="headerlink" title="leetcode-22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">leetcode-22. 括号生成</a></h2><p>ACM模式</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">dfs:</span><br><span class="hljs-comment">一个合法的括号序列：</span><br><span class="hljs-comment">1、任意前缀中，左括号的数量 一定 &gt;= 右括号的数量</span><br><span class="hljs-comment">2、左右括号数量相等 n == n</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">_ _ _ _</span><br><span class="hljs-comment">什么情况下可以填左括号：lcnt &lt; n 就可以填</span><br><span class="hljs-comment">什么情况下可以填右括号：rcnt &lt; n &amp;&amp;  左括号数量严格大于右括号数量lcnt &gt; rcnt，</span><br><span class="hljs-comment">才能填</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> n;<br>vector&lt;string&gt; res;<br><br><span class="hljs-comment">// 括号的对数n，左括号个数lcnt，右括号个数rcnt，str括号序列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lcnt, <span class="hljs-type">int</span> rcnt, string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-comment">// if (u == 2*n)</span><br>    <span class="hljs-keyword">if</span> (lcnt == n &amp;&amp; rcnt == n)<br>        res.<span class="hljs-built_in">push_back</span>(str);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (lcnt &lt; n)<br>            <span class="hljs-built_in">dfs</span>(n, lcnt+<span class="hljs-number">1</span>, rcnt, str+<span class="hljs-string">&#x27;(&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (rcnt &lt; n &amp;&amp; lcnt &gt; rcnt)<br>            <span class="hljs-built_in">dfs</span>(n, lcnt, rcnt+<span class="hljs-number">1</span>, str+<span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : res) cout &lt;&lt; x &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心代码模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lcnt, <span class="hljs-type">int</span> rcnt, string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (lcnt == n &amp;&amp; rcnt == n)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (lcnt &lt; n)<br>                <span class="hljs-built_in">dfs</span>(n, lcnt + <span class="hljs-number">1</span>, rcnt, str + <span class="hljs-string">&#x27;(&#x27;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (rcnt &lt; n &amp;&amp; lcnt &gt; rcnt)<br>                <span class="hljs-built_in">dfs</span>(n, lcnt, rcnt + <span class="hljs-number">1</span>, str + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;leetcode-22-括号生成&quot;&gt;&lt;a href=&quot;#leetcode-22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;leetcode-22. 括号生成&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>美团23秋招笔试后端</title>
    <link href="https://zzflybird.github.io/20220827589238093/"/>
    <id>https://zzflybird.github.io/20220827589238093/</id>
    <published>2022-08-27T13:11:59.000Z</published>
    <updated>2022-08-28T03:08:30.513Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2022-08-27 美团笔试</p></blockquote><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>样例：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">input:</span><br><span class="hljs-number">7</span> <span class="hljs-number">3</span><br>abcaacc<br>a*c<br><br><span class="hljs-symbol">output:</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">// 美团0827第一题</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">m 是短的那个子串的长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//bool check(string s1, string s2, int m)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="hljs-comment">//    for (int i = 0; i &lt; m; i++)</span><br><span class="hljs-comment">//    &#123;</span><br><span class="hljs-comment">//        if (s1[i] != &#x27;*&#x27; &amp;&amp; s1[i] != s2[i])</span><br><span class="hljs-comment">//            return false;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    return true;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    string s1, s2;<br><br>    cin &gt;&gt; s1 &gt;&gt; s2; <span class="hljs-comment">// s1 : abcaacc, s2: a*c</span><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">////////////////////////</span><br><span class="hljs-comment">//    for (int i = 0; i &lt;= n - m; i++)</span><br><span class="hljs-comment">//        // s1.substr(0, 3)左闭右开 -&gt; s1[0,2],</span><br><span class="hljs-comment">//        // 取s1的部分子串和 s2 进行比较，判断是否匹配，是返回1</span><br><span class="hljs-comment">//        res += check(s2, s1.substr(i, m), m) ? 1 : 0;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    cout &lt;&lt; res;</span><br><br>    <span class="hljs-comment">////////////////////////</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - m; i ++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 初始为true，如果s2和s1的子串tmp有不匹配的，就为false</span><br><br>        string tmp = s1.<span class="hljs-built_in">substr</span>(i, m); <span class="hljs-comment">// 子串的长度为 m</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s2[j] != <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; tmp[j] != s2[j])<br>                flag = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果满足m个字符都匹配，就把结果res ++;</span><br>        <span class="hljs-keyword">if</span> (flag) res ++;<br>    &#125;<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><blockquote><p><a href="https://www.nowcoder.com/discuss/1030726?type=post&order=create&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=082010163EA881CF7BA3CDE559BD38F9-1661610238016">c++版本</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">input:</span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">5 4 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5 3</span><br><span class="hljs-comment">3 4 3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">1 2 3 4 5</span><br><span class="hljs-comment">5 1 2 3 4</span><br><span class="hljs-comment">4 5 1 2 3</span><br><span class="hljs-comment">*3 4 5 1 2*</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-comment">// int a[N]; 使用vector而不是数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化vector</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        a[i - <span class="hljs-number">1</span>] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-comment">// 需要把x放到a数组的最左边，也就是先找到x并删除，再把x插入到a的首部</span><br>        a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), x));<br>        a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">begin</span>(), x);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wangcfbj/article/details/70269995">c++与Java的容器对着</a></p><blockquote><p>Java版本</p></blockquote><p>其中 c++ 的 map 就是 Java 的 TreeMap, key-value映射，按照key有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt(), m = sc.nextInt();<br>        Map&lt;Integer, Integer&gt; k2v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 有序 map 的定义</span><br>        TreeMap&lt;Integer, Integer&gt; v2k = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((x, y) -&gt; y - x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            <span class="hljs-keyword">if</span> (k2v.containsKey(num)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> k2v.get(num);<br>                v2k.remove(v);<br>                k2v.put(num, i);<br>                v2k.put(i, num);<br>            &#125;<br>            k2v.put(num, i);<br>            v2k.put(i, num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : v2k.keySet()) System.out.print(v2k.get(v) + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!k2v.containsKey(i)) System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>第三题</p></li><li><p>第四题</p></li><li><p>第五题</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2022-08-27 美团笔试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;p&gt;样例：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="面经" scheme="https://zzflybird.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>大疆测开笔试20220814</title>
    <link href="https://zzflybird.github.io/202208141197934275/"/>
    <id>https://zzflybird.github.io/202208141197934275/</id>
    <published>2022-08-14T12:47:24.000Z</published>
    <updated>2022-08-14T14:45:08.673Z</updated>
    
    <content type="html"><![CDATA[<p>1、<code>int * value [10][2]</code>, 32bit机器，问sizeof(*value)的大小?<br>个人感觉是4字节。32位机器；<br>如果是64位机器，int类型指针大小就是8字节的。</p><p>2、该正则表达式的匹配结果是？：<code>DJI\s(^Mavic|Mini)[0-3]?</code></p><p>3、 Linux系统中，进程的 VmHWM代表什么？<br>代表进程所占<strong>物理内存的峰值</strong>。</p><blockquote><p>cat &#x2F;proc&#x2F;pid&#x2F;status<br>VmPeak:     表示进程所占用最大虚拟内存大小<br>VmSize:      表示进程当前虚拟内存大小<br>VmLck:       表示被锁定的内存大小<br><strong>VmHWM:    表示进程所占用物理内存的峰值</strong><br>VmRSS:     表示进程当前占用物理内存的大小(与procrank中的RSS)<br>VmData:     表示进程数据段的大小<br>VmStk:       表示进程堆栈段的大小<br>VmExe:      表示进程代码的大小<br>VmLib:       表示进程所使用共享库的大小<br>VmPTE:      表示进程页表项的大小<br><a href="https://blog.csdn.net/weixin_38606457/article/details/125392137">查看某个进程占用空间大小 VmHWM VmRSS终极总结</a></p></blockquote><p>4、JVM的参数，<code>-Xmx10240m -Xms10240m -Xmn5120 -XX:SurvivorRatia=3</code>设置，问最小内存值 和 surviver区的总大小 分别是多少？</p><ul><li><strong>Xms</strong>: 指设定<strong>程序启动时占用的内存大小</strong>。</li><li><strong>Xmx</strong>：指设定程序运行期间<strong>最大可以占用的内存大小</strong>。如果程序运行时超出了这个设置值，就会报OutOfMemory异常。</li><li><strong>Xmn</strong>: 设置<strong>年轻代大小</strong>。<strong>整个堆大小&#x3D;年轻代大小+年老代大小+持久代大小。</strong></li><li>Xss:指设定的<strong>每个线程分配的堆栈内存大小</strong>。这个值根据程序，看一个线程大概需要多少内存，可能会有多少个线程同时运行来设置。</li><li><strong>XX:SurvivorRatia</strong>&#x3D;n, <strong>设置年轻代中 Eden区 与 2个Surviver区的大小比值</strong>。设置为3。注意 Survivor区 有2个。如n&#x3D;3，则表示Eden:Survivor&#x3D;3:2,一个Survivor区占年轻代的1&#x2F;5；如果设置为n&#x3D;4，则Eden:Sruvivor&#x3D;4:2, 一个Survivor区占年轻代的1&#x2F;6.</li></ul><p>结论：<br>所以最小内存值为 最初启动时的内存值，为Xms&#x3D;10240m,<br><code>-Xmn5120</code>说明年轻代大小是5120m，<code>-XX:SurvivorRatia=3</code>设置为3，说明Eden:Survivor&#x3D;3:2，一个Survivor区占年轻代的1&#x2F;5；所以一个Survivor区的大小为5120m*1&#x2F;5 &#x3D; 1024m, 但是年轻代中有2个Survivor区，所以 surviver区的总大小是 2048m.</p><p>5、Linux中，已有a.txt文件，哪个命令可以把该文件改名为txt.a ?<br>重定向机制， 使用<code>&gt;</code>表示输出到一个新文件中，使用<code>&gt;&gt;</code>表示输出到已有文件的末尾。如果文件已存在，直接操作文件，否者直接创建新文件。<br><a href="https://blog.csdn.net/Hongwei_1990/article/details/92382504">https://blog.csdn.net/Hongwei_1990/article/details/92382504</a><br><a href="https://www.51cto.com/article/207528.html">https://www.51cto.com/article/207528.html</a><br><a href="https://www.runoob.com/linux/linux-comm-cat.html">https://www.runoob.com/linux/linux-comm-cat.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;code&gt;int * value [10][2]&lt;/code&gt;, 32bit机器，问sizeof(*value)的大小?&lt;br&gt;个人感觉是4字节。32位机器；&lt;br&gt;如果是64位机器，int类型指针大小就是8字节的。&lt;/p&gt;
&lt;p&gt;2、该正则表达式的匹配结果是？：&lt;c</summary>
      
    
    
    
    <category term="面经" scheme="https://zzflybird.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://zzflybird.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>好未来笔试-Java-20220813</title>
    <link href="https://zzflybird.github.io/202208132751047154/"/>
    <id>https://zzflybird.github.io/202208132751047154/</id>
    <published>2022-08-13T12:50:11.000Z</published>
    <updated>2022-08-13T14:17:16.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><p>1、异或运算<br>2、栈的先入后出性质<br>3、引用类型和值类型创建对象和调用函数时分别会创建几个t对象？</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>func(t);<br><br>函数定义如下：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(T t)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>4、throw和throws的区别</p><ol><li>throws 关键字用于声明异常，它的作用和try-catch类似；而throw 关键字用于显示地抛出异常</li><li>throws 关键字后面跟异常的名字；而 throw 关键字后面跟的是异常的对象</li><li>throws 关键字出现在方法签名上；而 throw 关键字出现在方法体内部；</li><li>throws 关键字在声明异常时可以跟多个异常，用逗号隔开；而 throw 关键字每次只能抛出一个异常；</li></ol><p>5、TCP套接字函数哪个函数会发生阻塞？哪个不会产生阻塞？<br>accept(), bind(), write(), read()</p><p>6、子类A，父类B，父子类中均有：构造函数、静态代码块、非静态代码块；问 new 一个子类对象，这6个部分的调用顺序是怎么样的？</p><p>7、</p><h1 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h1><p>计算机中你了解的端口号和对应的服务有哪些？</p><blockquote><p>昨天看图解TCP刚看了端口号相关的，结果就记住了22，80常用的，其他的都忘了。。</p></blockquote><p>知名端口号: 0-1023分配</p><p>动态分配端口号的取值范围：49152-65535之间。</p><p>TCP知名端口号：<br>端口号-服务<br><strong>21-FTP<br>22-SSH</strong><br>23-telnet<br>25-SMTP<br><strong>20-HTTP</strong><br><strong>443-HTTPS, http protocol over TLS&#x2F;SSL<br>53-DNS</strong></p><h1 id="编程1：leetcode208-实现Trie前缀树"><a href="#编程1：leetcode208-实现Trie前缀树" class="headerlink" title="编程1：leetcode208 实现Trie前缀树"></a>编程1：leetcode208 实现Trie前缀树</h1><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></p><blockquote><p>好家伙，我在c++编译器里一直报错，一看结果是没有切换成Java语言</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children; <span class="hljs-comment">// 当前节点有一个数组，存放子节点的值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isWord</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断到该节点的路径是否是一个完整的单词</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化前缀树对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isWord = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向前缀树中插入字符串 word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<span class="hljs-comment">// 当前this就是根节点</span><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>            <span class="hljs-comment">// 子节点为空，创建新的节点,移动到子节点</span><br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>                node = node.children[idx]; <span class="hljs-comment">// 移动到根节点的子节点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        node.isWord = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记字符串末尾</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断 word 是否是树中的完整字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-comment">// 数组索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>            <span class="hljs-comment">// 不存在，直接返回false</span><br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isWord;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断 树中是否有 word 出现，前缀也可以</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-keyword">for</span> (Character ch : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                node = node.children[idx];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只要遍历完word了，就直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程2：leetcode-hard-25-K-个一组翻转链表"><a href="#编程2：leetcode-hard-25-K-个一组翻转链表" class="headerlink" title="编程2：leetcode hard 25. K 个一组翻转链表"></a>编程2：leetcode hard 25. K 个一组翻转链表</h1><p>高频题，刷的时候跳过了</p><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单选&quot;&gt;&lt;a href=&quot;#单选&quot; class=&quot;headerlink&quot; title=&quot;单选&quot;&gt;&lt;/a&gt;单选&lt;/h1&gt;&lt;p&gt;1、异或运算&lt;br&gt;2、栈的先入后出性质&lt;br&gt;3、引用类型和值类型创建对象和调用函数时分别会创建几个t对象？&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计网常见问题记录</title>
    <link href="https://zzflybird.github.io/202208071957406245/"/>
    <id>https://zzflybird.github.io/202208071957406245/</id>
    <published>2022-08-07T03:13:35.000Z</published>
    <updated>2022-08-14T03:51:09.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更全、更深</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="一台服务器最大可以支撑多少条TCP连接？"><a href="#一台服务器最大可以支撑多少条TCP连接？" class="headerlink" title="一台服务器最大可以支撑多少条TCP连接？"></a>一台服务器最大可以支撑多少条TCP连接？</h2><p>理论上，一条TCP连接由一个四元组组成，分别是<strong>源IP地址，目的IP地址，源端口号，目的端口号</strong>。任意一个元素发生了改变，就代表的是一条完全不同的连接了。</p><p>对于服务端：<br>拿服务端的Nginx举例，服务端的IP地址是固定的，端口号是固定的80，只有源IP地址、源端口号是可变的。IPv4地址是32位，有$2^32$个IP数，端口号是16位，有$2^16&#x3D;65535$个port数。因此，理论上Nginx最多可以建立$2^32 * 2^16$个连接。</p><p>对于BS架构的浏览器端来说：<br>源IP地址和源端口号是不变的，目的端（服务器端）的端口号是80端口，是不变的，唯一可变的就是服务器端的IP地址是可变的。如果是IPv4网络下，IP地址是32位的，那么浏览器最多能够建立$2^32$个连接。</p><p>服务器能处理的并发数量和处理每个连接的数据处理工作量有关：<br>如果只建立连接不发送数据，不接收数据，服务器对cpu的需求就很少，只有处理连接握手的时候才需要一些资源。</p><p>但是，每维持一条TCP连接，就需要创建一个文件对象。（因为Linux是一切皆文件，socket也是文件）</p><h2 id="重发超时如何确定？"><a href="#重发超时如何确定？" class="headerlink" title="重发超时如何确定？"></a>重发超时如何确定？</h2><p>重发超时指的是 在重发数据之前，等待确认应答到来的那个特定时间间隔。<br>如果超过这个时间仍然没有收到确认应答，发送端就认为数据丢失，会重发数据。</p><p>TCP在发送数据包时会计算 往返时间（Round Trip Time, RTT，指报文段的往返时间）和偏差（往返时间波动的值、方差，有时也叫抖动）。</p><p><strong>重发超时的时间，是比 往返时间+偏差 稍大一点的值。</strong></p><ul><li>数据重发后，如果还是收不到确认应答，就再次发送数据。这时，重发时间会以2倍、4倍的指数函数变大。</li><li>数据不会被无线重发。达到一定重发次数后，还是收不到确认应答，就判断为网络或对方主机发生异常，强制关闭连接；并通知应用通信异常强行终止。</li></ul><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><p>TCP是面向连接的，面向连接是指在发生数据之前要先做好通信两端的准备工作，建立连接，然后再发送数据。<br>UDP是面向无连接的，不检查对端是否可以通信，直接将UDP包发送出去。</p><ul><li><p>TCP在数据通信前，通过TCP首部发送一个SYN包，请求建立连接，并等待对方的确认应答。如果对方发来确认应答ACK和SYN，则针对对方的SYN发送确认应答ACK，确认建立连接。</p></li><li><p>一个TCP连接的建立和断开，正常过程至少需要来回发送7个包才能完成：建立连接需要发送3个包，三次握手；断开连接4个包，4次挥手。</p></li></ul><h2 id="TCP以段位单位发送数据"><a href="#TCP以段位单位发送数据" class="headerlink" title="TCP以段位单位发送数据"></a>TCP以段位单位发送数据</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods</a></p></blockquote><h2 id="你知道哪些-HTTP-请求方法？"><a href="#你知道哪些-HTTP-请求方法？" class="headerlink" title="你知道哪些 HTTP 请求方法？"></a>你知道哪些 HTTP 请求方法？</h2><blockquote><p>HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。<br>其中 GET 和 POST 的区别是 …； 其中 OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法的作用是 …。</p></blockquote><h2 id="HTTP-1-0-和-HTTP-1-1-甚至和-HTTP-x2F-2-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-甚至和-HTTP-x2F-2-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 甚至和 HTTP&#x2F;2 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 甚至和 HTTP&#x2F;2 有什么区别？</h2><blockquote><p>HTTP 1.x ,HTTP&#x2F;2 的对比区别</p></blockquote><h5 id="ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？"><a href="#ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？" class="headerlink" title="ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？"></a>ipv4网络下，浏览器端理论上可以和服务端建立多少个连接呢？</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;更全、更深&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;h2 id=&quot;一台服务器最大可以支撑多少条TCP连接？&quot;</summary>
      
    
    
    
    <category term="面经" scheme="https://zzflybird.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计网" scheme="https://zzflybird.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中的值传递</title>
    <link href="https://zzflybird.github.io/202208063305694406/"/>
    <id>https://zzflybird.github.io/202208063305694406/</id>
    <published>2022-08-06T08:13:11.000Z</published>
    <updated>2022-08-07T03:10:49.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尽量用自己的话说明白</p></blockquote><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><p>首先，Java中只有值传递。</p><ul><li>对于基本数据类型，传递的值的内容是 实参的值的拷贝；</li><li>对于对象，传递的值的内容是 实参的地址的拷贝；</li></ul><p>Java中调用函数时，传入的是实参，函数的定义中括号内的是形参。</p><h2 id="对于基本数据类型-int-double"><a href="#对于基本数据类型-int-double" class="headerlink" title="对于基本数据类型 int double"></a>对于基本数据类型 int double</h2><p>对于调用函数<code>func(int a)</code>，先将传入的实参复制一份，然后将该复制的值传递给形参。<br>形参得到的是一个值的复制，是局部的，对于这个局部值的改变不会影响实际参数的值。</p><h2 id="对于对象-Object"><a href="#对于对象-Object" class="headerlink" title="对于对象 Object"></a>对于对象 Object</h2><p>调用函数<code>func(Object obj)</code>，先将传入的实参的<strong>地址</strong>复制一份，然后将该地址的拷贝传递给被调函数的形参。<br>这样，现在就有2个地址的值，分别是原来的实参的地址和拷贝得到的地址，这两个地址指向堆中同一个对象。<br>此时，对于形参所指的对象进行变更，就会改变实际参数的值。</p><p>参考资料：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1659755520&amp;ver=3965&amp;signature=KUjgtEnSxCuO8nEbIM18w8Z8a4TEbXL0MdxMxSeNcDDnMcmk-oqgSsixtbFQQr7CDWCaYJX*nPD0xjb9pJTM-1F7fGH2qu7u5SN8QI3l7SrIM2vKHppWek8FQLQ2yggi&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1659755520&amp;ver=3965&amp;signature=KUjgtEnSxCuO8nEbIM18w8Z8a4TEbXL0MdxMxSeNcDDnMcmk-oqgSsixtbFQQr7CDWCaYJX*nPD0xjb9pJTM-1F7fGH2qu7u5SN8QI3l7SrIM2vKHppWek8FQLQ2yggi&amp;new=1</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尽量用自己的话说明白&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;值传递&quot;&gt;&lt;a href=&quot;#值传递&quot; class=&quot;headerlink&quot; title=&quot;值传递&quot;&gt;&lt;/a&gt;值传递&lt;/h1&gt;&lt;p&gt;首先，Java中只有值传递。&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="面经" scheme="https://zzflybird.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://zzflybird.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-200. 岛屿数量</title>
    <link href="https://zzflybird.github.io/202208021778491728/"/>
    <id>https://zzflybird.github.io/202208021778491728/</id>
    <published>2022-08-02T14:16:33.000Z</published>
    <updated>2022-08-02T14:18:34.090Z</updated>
    
    <content type="html"><![CDATA[<p>flood fill 算法</p><p>给定二位矩阵，搜索其中的1的连通块的数量</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul><li>岛屿问题：LC695&#x2F;LC827&#x2F;LC463&#x2F;LC200，+L1254+ LC994</li><li>被问到深度优先和广度优先的差别、计算时间空间复杂度</li><li>深度OR广度OR并查集都可</li><li>微软follow up题：827. 最大人工岛，MS follow up: 只允许一个水变成陆地，最大岛屿面积是多少？****<a href="https://leetcode.cn/problems/making-a-large-island/">827. 最大人工岛</a>****</li><li><strong><strong><a href="https://www.cnblogs.com/lzw-lxy/p/16098424.html">leetcode 694 不同的岛屿数量</a></strong></strong></li><li>DFS+BFS+<strong>并查集</strong></li><li>网易互娱笔试</li><li>美团二面</li><li>火山一面</li><li>字节AI LAB一面</li><li>抖音后端二面</li><li>飞书2 15</li></ul><h1 id="方法1：DFS-找是1的陆地"><a href="#方法1：DFS-找是1的陆地" class="headerlink" title="方法1：DFS, 找是1的陆地"></a>方法1：DFS, 找是1的陆地</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j);<br>                    <span class="hljs-comment">// bfs(&#123;i, j&#125;);</span><br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-comment">// dfs代码</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 遍历过的位置，变为0, 防止重复遍历</span><br>        g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 向4个方向找1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-comment">// 计算 下一个位置的坐标(a,b)</span><br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-comment">// 下一个位置(a,b)上也是1，就继续dfs</span><br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; g[a][b] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-built_in">dfs</span>(a, b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法：DFS-，-避免0和2"><a href="#方法：DFS-，-避免0和2" class="headerlink" title="方法：DFS ， 避免0和2"></a>方法：DFS ， 避免0和2</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j);<br>                    <span class="hljs-comment">// bfs(&#123;i, j&#125;);</span><br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br><br>    <span class="hljs-comment">// dfs代码</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 遍历过的位置，标记为2, 防止重复遍历</span><br>        g[x][y] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <br>        <span class="hljs-comment">// 向4个方向找1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>        &#123;<br>            <span class="hljs-comment">// 计算 下一个位置的坐标(a,b)</span><br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br><br>            <span class="hljs-comment">// 判断 base case</span><br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= g.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (g[a][b] == <span class="hljs-string">&#x27;2&#x27;</span> || g[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(a,b);<br><br>            <span class="hljs-comment">// 下一个位置(a,b)上也是1，就继续dfs</span><br>            <span class="hljs-comment">// if (a &gt;= 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; g[0].size() &amp;&amp; g[a][b] == &#x27;1&#x27;)</span><br>            <span class="hljs-comment">//     dfs(a, b);</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="方法2：BFS"><a href="#方法2：BFS" class="headerlink" title="方法2：BFS"></a>方法2：BFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 全局变量</span><br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-comment">// 先定义4个方向</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录连通块的个数</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>            &#123;<br>                <span class="hljs-comment">// 找1的连通块</span><br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// dfs(i,j);</span><br>                    <span class="hljs-built_in">bfs</span>(&#123;i, j&#125;);<br>                    cnt ++; <span class="hljs-comment">// 上面每搜完一个连通块，就把cnt+1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(PII p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;PII&gt; q;<br>        q.<span class="hljs-built_in">push</span>(p);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            PII t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// 拓展4个方向</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>            &#123;<br>                <span class="hljs-comment">// 下一个位置的坐标(a,b)</span><br>                <span class="hljs-type">int</span> a = t.first + dx[i], b = t.second + dy[i];<br>                <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= g.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || g[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                g[a][b] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                q.<span class="hljs-built_in">push</span>(&#123;a,b&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;flood fill 算法&lt;/p&gt;
&lt;p&gt;给定二位矩阵，搜索其中的1的连通块的数量&lt;/p&gt;
&lt;h1 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;岛屿问题：LC695&amp;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-20. 有效的括号</title>
    <link href="https://zzflybird.github.io/202208024026458204/"/>
    <id>https://zzflybird.github.io/202208024026458204/</id>
    <published>2022-08-02T14:15:44.000Z</published>
    <updated>2022-08-02T14:18:34.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈-map"><a href="#栈-map" class="headerlink" title="栈+map"></a>栈+map</h1><ul><li><p>最后判断栈是否为空，如果不为空说明有单独的左括号</p></li><li><p>这里最后一定要看看栈是不是空的！！！</p></li><li><p>阿里面试，问“左括号必须以正确的顺序闭合”，这个条件去掉如何实现？</p><p>  需要用三个遍历记录三种左括号的数量。然后遍历字符串，遍历过程中，遇到右括号就把对应的左括号的数量减去。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针？错！</span><br>        <span class="hljs-comment">// 栈 + map </span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; umap;<br><br>        umap[<span class="hljs-string">&#x27;[&#x27;</span>] = <span class="hljs-string">&#x27;]&#x27;</span>;<br>        umap[<span class="hljs-string">&#x27;(&#x27;</span>] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        umap[<span class="hljs-string">&#x27;&#123;&#x27;</span>] = <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)<br>        &#123;<br>            <span class="hljs-comment">// 如果是左括号，入栈</span><br>            <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(ch))<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 是右括号，</span><br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || umap[stk.<span class="hljs-built_in">top</span>()] != ch)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 如果所有括号都有效匹配，栈应为空</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈-map&quot;&gt;&lt;a href=&quot;#栈-map&quot; class=&quot;headerlink&quot; title=&quot;栈+map&quot;&gt;&lt;/a&gt;栈+map&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最后判断栈是否为空，如果不为空说明有单独的左括号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里最后一定要</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-33. 搜索旋转排序数组</title>
    <link href="https://zzflybird.github.io/202208013616194023/"/>
    <id>https://zzflybird.github.io/202208013616194023/</id>
    <published>2022-08-01T14:51:27.000Z</published>
    <updated>2022-08-02T14:18:22.381Z</updated>
    
    <content type="html"><![CDATA[<p>二分：整数二分细节比较多，实数二分比较简单</p><p>二段性：找一个性质，第一段满足，第二段不满足，二分出边界点，边界点就是，满足性质的第一段的最后一个数。</p><p>两次2分，第一次二分出来数组中的断层的点，第二次在单调序列中二分找tar</p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul><li>这道题要注意：如果面试官问你再旋转一次怎么做，做法还是一样的，无论旋转几次，最多只有2段递增序列</li><li>33的加强版是81题； 这两个题的基础是153和154题。</li><li>33-查找旋转数组不重复；81-查找旋转数组可重复复；153-旋转数组最小值不重复；154旋转数字最小值重复，这几个一起做做，二分的题目太难太细节，需要对比</li><li>二分。重点在于先判断哪半段是有序的，然后判断目标是否在有序的那半里面。</li><li>基础: 153.33. 进阶：154.81.</li></ul><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>两次二分，第一次二分找到左边区间的最大值；判断target在哪个区间，重新划分区间；第二次二分在新的区间中找target</p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc33-2022-08-02_101009.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 想法1：找到数组中下标i，满足nums[i] &gt; nums[i+1], 然后恢复数组为升序</span><br>        <span class="hljs-comment">// 接着使用二分，找tar</span><br>        <span class="hljs-comment">// y总思路：一般是有序，找一个二段性就可以二分，本题数组中间断开，所以先找断开的点在哪里</span><br>        <span class="hljs-comment">// 然后判断target是在断点的左边区间还是右边区间，再该区间中再次使用二分找到target</span><br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[<span class="hljs-number">0</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时 ，nums[r] 就是 前半部分的最大值</span><br><br>        <span class="hljs-comment">// 接着判断target在哪个部分</span><br>        <span class="hljs-keyword">if</span> (target &gt;= nums[<span class="hljs-number">0</span>]) l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> l = r + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 继续二分，在目标有序区间中找到target</span><br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时的l=r就是target的下标，如果没找到，就是-1</span><br>        <span class="hljs-keyword">if</span> (nums[r] == target) <span class="hljs-keyword">return</span> r;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二分：整数二分细节比较多，实数二分比较简单&lt;/p&gt;
&lt;p&gt;二段性：找一个性质，第一段满足，第二段不满足，二分出边界点，边界点就是，满足性质的第一段的最后一个数。&lt;/p&gt;
&lt;p&gt;两次2分，第一次二分出来数组中的断层的点，第二次在单调序列中二分找tar&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-103. 二叉树的锯齿形层序遍历</title>
    <link href="https://zzflybird.github.io/202208012018291730/"/>
    <id>https://zzflybird.github.io/202208012018291730/</id>
    <published>2022-08-01T14:51:14.000Z</published>
    <updated>2022-08-01T14:54:21.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实战案例："><a href="#实战案例：" class="headerlink" title="实战案例："></a>实战案例：</h1><ul><li>先是<strong>二叉树层序遍历</strong>，然后改成<strong>锯齿形遍历</strong>，除此之外，题目还要求符合一定的打印格式。一开始我是用的一个vector作为中间变量储存，然后面试官要求不用vector写一个优化的方法。然后我就考虑用<strong>双向队列</strong>。</li><li><strong>阿里变体，n叉树，3层为周期反转</strong></li><li>BFS加一个标记sign，sign为false表示从左到右，元素append到最后，true表示从右到左，元素append到最前面。每遍历一层转换下sign（sign &#x3D; !sign）</li><li>使用两个栈，利用栈的FILO特性实现反转</li><li>阿里面的时候考过这个题，我用了两个栈搞的哈哈哈，但是其实用个flag和一个count控制反转入栈的方向即可</li><li>双栈或者双端队列</li><li>微软算法题</li><li><strong>记得用dfs实现一遍</strong></li></ul><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>2点需要注意：</p><p>1、使用deque双端队列；</p><p>2、使用isLeft2Right来表示从左向右，还是从右向左，最后变更方向。</p><p>代码中注释为重要的，即为于常规的层序遍历不同的地方，因为本题每一层保存的数组顺序是不同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-comment">// 层序遍历的变体：使用双端队列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">bool</span> isLeft2Right = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重要：初始第0层根节点是 从左往右</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> qsize = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// vector&lt;int&gt; tmp; 把vec变为 deque 双向队列</span><br>            deque&lt;<span class="hljs-type">int</span>&gt; levelList; <span class="hljs-comment">// 重要：用 deque代替vector存数值</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; qsize; i++)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-comment">// 重要：如果 isLeft2Right 为true，就把值放到 双端队列队尾，否则就放到队头</span><br>                <span class="hljs-keyword">if</span> (isLeft2Right) <br>                    levelList.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">else</span> <br>                    levelList.<span class="hljs-built_in">push_front</span>(node-&gt;val);<br>                <span class="hljs-comment">// tmp.push_back(node-&gt;val);</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-comment">// 重要：将deque队列保存到vector中，再放入res中</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(levelList.begin(), levelList.end())</span></span>;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-comment">// 重要：修改存储方向</span><br>            isLeft2Right = !isLeft2Right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>1、终止条件</p><p>2、层数level的判断条件</p><p>3、 如何保存val，根据level的奇偶判断</p><p>4、递归左右孩子节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 如果 level &gt;= res.size()说明下一层的集合还没创建，所以要先创建下一层的集合</span><br>        <span class="hljs-keyword">if</span> (level &gt;= res.<span class="hljs-built_in">size</span>()) <br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br>        <span class="hljs-comment">// 普通的保存val</span><br>        <span class="hljs-comment">// res[level].push_back(root-&gt;val);</span><br>        <br>        <span class="hljs-comment">// 根据level选择在vector的前面还是后面保存val，若 level为偶，则在 vector 的后面追加保存元素；</span><br>        <span class="hljs-comment">// 若为奇，则在vector的begin()开头插入值</span><br>        <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">else</span> res[level].<span class="hljs-built_in">insert</span>(res[level].<span class="hljs-built_in">begin</span>(), root-&gt;val);<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, level+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>); <span class="hljs-comment">// 根节点层的 层数 level = 0</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实战案例：&quot;&gt;&lt;a href=&quot;#实战案例：&quot; class=&quot;headerlink&quot; title=&quot;实战案例：&quot;&gt;&lt;/a&gt;实战案例：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;先是&lt;strong&gt;二叉树层序遍历&lt;/strong&gt;，然后改成&lt;strong&gt;锯齿形遍历&lt;/strong</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-142. 环形链表 II</title>
    <link href="https://zzflybird.github.io/202208013254481510/"/>
    <id>https://zzflybird.github.io/202208013254481510/</id>
    <published>2022-08-01T14:51:02.000Z</published>
    <updated>2022-08-01T14:54:21.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环形链表三连问："><a href="#环形链表三连问：" class="headerlink" title="环形链表三连问："></a>环形链表三连问：</h2><ol><li><p>是否有环 141</p></li><li><p>找出环的入口 142</p></li><li><p>环中节点个数</p></li></ol><h2 id="如何计算环中节点个数"><a href="#如何计算环中节点个数" class="headerlink" title="如何计算环中节点个数?"></a>如何计算环中节点个数?</h2><p>idx1和idx2相遇在环的入口, 让idx2单独在环里再走一圈, 并进行计数, 当idx2→next &#x3D;&#x3D; idx1时, 返回count+1, 就是所谓的环中节点的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录环中节点个数, 最初节点个数为1</span><br><br>            <span class="hljs-keyword">if</span> (fast == slow)<br>            &#123;<br>                <span class="hljs-comment">// 找到相遇节点</span><br>                ListNode* idx1 = head;<br>                ListNode* idx2 = fast;<br>                <span class="hljs-keyword">while</span> (idx1 != idx2)<br>                &#123;<br>                    idx1 = idx1-&gt;next;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                <span class="hljs-comment">// 3 记录环中节点个数</span><br>                <span class="hljs-keyword">while</span> (idx2-&gt;next != idx1)<br>                &#123;<br>                    cnt++;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                cout &lt;&lt; cnt &lt;&lt; endl;<br>                <span class="hljs-comment">// 如果idx1=idx2，就是环的入口</span><br>                <span class="hljs-keyword">return</span> idx1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 链表无环返回NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>1 如何判断有环 2 环内相遇点 3 环的入口点</p><p>最重要的就是找到环的入口，</p><p>数学证明：</p><p>把环形链表分为三部分</p><ul><li>头节点—-》环的入口节点 的节点数是 x</li><li>环入口节点—》环内相遇节点 的节点数量是 y</li><li>相遇节点—》环入口节点 的节点数量是z</li></ul><p>快慢指针：</p><p>fast指针每次走2步，slow指针每次走1步</p><p>当fast和slow指针相遇的时候，因为slow指针走的慢，所以走了x+y个节点；</p><p>fast指针走的快，所以肯定会追上slow指针，所以一共走了 x+y + n(y+z)个节点；fast指针肯定要在环中多走几圈才能追上slow指针；</p><p>又因为fast指针走的步数是slow指针的2倍；</p><p>所以有 2*slow走的步数 &#x3D; fast走的步数，</p><p>即 2*(x+y) &#x3D;  x+y + n(y+z)，</p><p>化简得：</p><p>x+y &#x3D; n(y+z)，拆出来一个y+z，则有</p><p>x + y &#x3D; (n-1)*(y+z) + y + z</p><p>x &#x3D; (n-1)(y+z)  + z，其中n ≥ 1</p><p>当n&#x3D;1，时，有 x  &#x3D; z ;</p><p>即 下面2个节点数是相同的</p><ul><li>头节点—-》环的入口节点 的节点数是 x</li><li>相遇节点—》环入口节点 的节点数量是z</li></ul><p>因此，头节点位置是已知的，先找到快慢指针的相遇节点，</p><p>然后分别从头节点和相遇节点向下走1步，相遇的节点就是 环的入口节点。</p><p>先找到快慢指针相遇的节点，然后分别从头节点和相遇节点向前走，2指针相遇的地方，就是环的入口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 本题和 141 的区别，需要 返回链表开始入环的第一个节点</span><br><br>        <span class="hljs-comment">// 字节-判断是否有环，并打印首尾节点</span><br>        <span class="hljs-comment">// 写了个快慢指针，问能不能再优化</span><br>        <span class="hljs-comment">// x,y,z , 证明出 x = z就行 </span><br>        <span class="hljs-comment">// idx1从头节点出发，idx2从相遇节点出发，然后各自每次走1步，相遇的节点就是环的入口节点</span><br><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span> (fast == slow)<br>            &#123;<br>                <span class="hljs-comment">// 找到相遇节点</span><br>                ListNode* idx1 = head;<br>                ListNode* idx2 = fast;<br>                <span class="hljs-keyword">while</span> (idx1 != idx2)<br>                &#123;<br>                    idx1 = idx1-&gt;next;<br>                    idx2 = idx2-&gt;next;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果idx1=idx2，就是环的入口</span><br>                <span class="hljs-keyword">return</span> idx1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 链表无环返回NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环形链表三连问：&quot;&gt;&lt;a href=&quot;#环形链表三连问：&quot; class=&quot;headerlink&quot; title=&quot;环形链表三连问：&quot;&gt;&lt;/a&gt;环形链表三连问：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否有环 141&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;找出环的入口 142&lt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-141. 环形链表</title>
    <link href="https://zzflybird.github.io/202208011400605890/"/>
    <id>https://zzflybird.github.io/202208011400605890/</id>
    <published>2022-08-01T14:50:49.000Z</published>
    <updated>2022-08-01T14:54:21.949Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针, 双指针</span><br>        <span class="hljs-comment">// fast 走2步，slow走1步，2指针相遇说明有环</span><br><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">// fast 走2步， slow 走1步</span><br>            fast = fast-&gt;next-&gt;next; <span class="hljs-comment">// 注意：fast-&gt;next 不能为 NULL, 否则会报空指针错误</span><br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-comment">// 直接比较 指针是否相等，不用比较 fast-&gt;val == slow-&gt;val了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode-122. 买卖股票的最佳时机 II</title>
    <link href="https://zzflybird.github.io/202207313064434135/"/>
    <id>https://zzflybird.github.io/202207313064434135/</id>
    <published>2022-07-31T03:53:56.000Z</published>
    <updated>2022-08-02T14:18:16.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本题可买—》卖多次</strong></p><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc-122-2022-07-31_112441.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 可交易多次，即卖出状态可继续买入</span><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n ; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>-prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]), dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本题可买—》卖多次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc-122-2022-07-31_</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-121. 买卖股票的最佳时机</title>
    <link href="https://zzflybird.github.io/202207312393907320/"/>
    <id>https://zzflybird.github.io/202207312393907320/</id>
    <published>2022-07-31T03:50:37.000Z</published>
    <updated>2022-08-02T03:17:54.012Z</updated>
    
    <content type="html"><![CDATA[<p>前一天买入，未来一个不同的日子才能卖出</p><p><strong>不能多次交易，只能买—》卖一次</strong><br><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/lc121-2022-07-31_110458.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 买入股票，在后面卖出。可以买卖多次吗？应该是不可以</span><br>        <span class="hljs-comment">// dp[i][0]：持有股票的最大利润</span><br>        <span class="hljs-comment">// dp[i][1]：卖出股票的最大利润</span><br><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 二维数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>-prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前一天买入，未来一个不同的日子才能卖出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不能多次交易，只能买—》卖一次&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zzflybird/my-images/master/hex</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-53. 最大子数组和</title>
    <link href="https://zzflybird.github.io/20220730390932531/"/>
    <id>https://zzflybird.github.io/20220730390932531/</id>
    <published>2022-07-30T14:30:01.000Z</published>
    <updated>2022-07-30T14:36:52.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 子数组是连续的部分</span><br>        <span class="hljs-comment">// dp问题</span><br>        <span class="hljs-comment">// dp[i]:表示数组nums[0,i]的最大连续子数组的和为dp[i]</span><br>        <span class="hljs-comment">// dp[0] = nums[0]</span><br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; res) res = dp[i];<span class="hljs-comment">// 保存连续子数组最大和</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zzflybird/my-images/master/hexo-blog-img/Untitled.png"></p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 贪心思路：遍历求和，如果和小于0，这和不要也罢，直接从下一个元素开始累加和</span><br><br>        <span class="hljs-type">int</span> res = INT32_MIN;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [-1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            sum += nums[i];<br>            <span class="hljs-comment">// 先使用sum更新res，否则先判断sum&lt;0的话会把sum的值变为0，就丢失了原来的值了。</span><br>            <span class="hljs-keyword">if</span> (sum &gt; res) res = sum;<span class="hljs-comment">// 先更新res</span><br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 再把小于0的sum变为0</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;dp&quot;&gt;&lt;a href=&quot;#dp&quot; class=&quot;headerlink&quot; title=&quot;dp&quot;&gt;&lt;/a&gt;dp&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-21. 合并两个有序链表</title>
    <link href="https://zzflybird.github.io/20220730636993472/"/>
    <id>https://zzflybird.github.io/20220730636993472/</id>
    <published>2022-07-30T14:28:51.000Z</published>
    <updated>2022-07-30T14:36:48.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>迭代和递归写法</li><li>面试时会考虑去重，迭代去重在比较前判断pre和l1和l2的大小，决定是否要跳过该节点</li><li>变形：<strong>合并多个有序列表</strong>：<strong>合并多个有序链表的实现思路，分析时间复杂度和空间复杂度</strong>。方法：以合并两个链表的思路为基础，使用归并自底向上合并。还有小顶堆，也就是优先队列。</li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1000</span>); <span class="hljs-comment">// 虚拟节点，为了返回列表方便</span><br><br>        ListNode* pre = dummy; <span class="hljs-comment">// 操作指针</span><br><br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">NULL</span> &amp;&amp; list2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">// 如果需要去重的话，先比较pre-&gt;val 和 list1, list2的val</span><br>            <span class="hljs-comment">// if (pre-&gt;val == list1-&gt;val) list1 = list1-&gt;next;</span><br>            <span class="hljs-comment">// if (pre-&gt;val == list2-&gt;val) list2 = list2-&gt;next;</span><br><br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) <br>            &#123;<br>                pre-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>                pre = pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                pre-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>                pre = pre-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最终有一个链表没有遍历完，就接在pre的后面.</span><br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">NULL</span>) pre-&gt;next = list2;<br>        <span class="hljs-keyword">else</span> pre-&gt;next = list1;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l1;<br><br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) <br>        &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;迭代和递归写法&lt;/li&gt;
&lt;li&gt;面试时会考虑去重，迭代去重在比较前判断pre和l1和l2的大小，决定是否要跳过该节点&lt;/li&gt;
&lt;li&gt;变形：&lt;strong&gt;合并多个有序列表&lt;/strong&gt;：&lt;strong&gt;合并多个有序链表的实现思路，分析时间复杂度和空间复</summary>
      
    
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://zzflybird.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
